require("system/iofiles")

---@class QuestData
---@field id integer
---@field global boolean
---@field type integer
---@field progress integer Current quest progress
---@field requirement integer Required quest progress for it to be completed
---@field timeleft integer Time left until quest expiry
---@field modid integer ID of the mod required for quest progression
---@field modname string Name of the mod required for quest progression
---@field decap boolean If true, quest requires the player to decap an opponent during the fight
---@field matchmake boolean If true, quest requires the fight to be played in matchmaking mode
---@field official boolean If true, quest requires the fight to be played in an official (static) room. *Regular quests only*.
---@field reward integer Reward amount
---@field rewardid integer Item ID of the reward. If zero, `reward` value indicates TC reward.
---@field name string Custom or autogenerated quest name
---@field ranked boolean If true, quest requires the fight to be played in ranked mode. *Regular quests only*.
---@field claimed boolean Whether the quest has been completed by the user. *Global quests only*.
---@field available boolean Whether the quest is currently available for the user. *Global quests only*.
---@field progresspercentage number Quest progress percentage
---@field description string Additional information about the quest

if (Quests == nil or TB_MENU_DEBUG) then
	-- Quests manager class
	--
	-- **Ver 1.3 updates:**
	-- * Updated visuals to show all quests same as global quests from previous versions
	-- * Quests:showGlobalQuestButton() is now Quests:showQuestButton()
	--
	-- **Ver 1.2 updates:**
	-- * Allow scrolling the quests list if there are too many of them to not shrink the buttons by too much
	---@class Quests
	---@field QuestsData QuestData[] Table containing all active regular quests for current user
	---@field QuestsGlobalData QuestData[] Table containing information on all global quests for the user
	---@field QuestDataErrors integer Will be non-zero if quest data file parsing resulted in an error
	Quests = {
		__index = {},
		ver = 1.3,
		QuestsData = nil,
		QuestsGlobalData = nil,
		QuestDataErrors = 0
	}
	setmetatable({}, Quests)
end

---Downloads quests data file and stores last update time to QUESTS_UPDATE_CLOCK.\
---Will not queue the file for download if it's already in download queue or has been downloaded within past 5 seconds.
---@return boolean #Whether file download has been initiated
function Quests:download()
	local clock = os.clock()
	if (clock - (QUESTS_UPDATE_CLOCK or 0) < 5) then
		return false
	end

	local downloads = get_downloads()
	for i,v in pairs(downloads) do
		if (v:find("quest.txt$")) then
			return false
		end
	end

	QUESTS_UPDATE_CLOCK = clock
	Quests.QuestsData = nil
	download_quest(TB_MENU_PLAYER_INFO.username)
	return true
end

---Parses information about available quests from the data file.\
---If data file is missing, increments Quests.QuestDataErrors and queues it for download.
---@return nil
function Quests:getQuests()
	TB_MENU_QUESTS_COUNT = 0
	local file = Files:open("../data/quest.txt")
	if (not file.data) then
		Quests:download()
		Quests.QuestDataErrors = Quests.QuestDataErrors + 1
	end

	---@type QuestData[]
	local questData = {}
	local dataTypes = {
		{ "id", numeric = true },
		{ "type", numeric = true },
		{ "progress", numeric = true },
		{ "requirement", numeric = true },
		{ "timeleft", numeric = true },
		{ "modid", numeric = true },
		{ "modname" },
		{ "decap", boolean = true },
		{ "matchmake", boolean = true },
		{ "official", boolean = true },
		{ "reward", numeric = true },
		{ "rewardid", numeric = true },
		{ "name" },
		{ "ranked", boolean = true }
	}

	for i, ln in pairs(file:readAll()) do
		if (not ln:find("^#")) then
			local _, segments = ln:gsub("([^\t]*)\t?", "")
			local dataStream = { ln:match(("([^\t]*)\t?"):rep(segments)) }

			---@type QuestData
			local quest = {}
			for i,v in pairs(dataTypes) do
				if (v.numeric or v.boolean) then
					quest[v[1]] = tonumber(dataStream[i])
					if (v.boolean) then
						quest[v[1]] = quest[v[1]] == 1
					end
				else
					quest[v[1]] = dataStream[i]
				end
			end
			quest.name = quest.name or Quests:getQuestName(quest)
			quest.description = Quests:getQuestObjective(quest)
			quest.progresspercentage = (quest.requirement / (quest.progress == 0 and 0.01 or quest.progress))
			table.insert(questData, quest)

			if (quest.progress >= quest.requirement) then
				TB_MENU_QUESTS_COUNT = TB_MENU_QUESTS_COUNT + 1
			end
		end
	end
	file:close()

	Quests.QuestsData = questData
end

---Returns quest data with the matching quest id. If no quest is found, returns `false`.
---@param id integer
---@return QuestData|boolean
function Quests:getQuestById(id)
	if (not Quests.QuestsData) then
		Quests:getQuests()
	end
	if (Quests.QuestsData) then
		for i,v in pairs(Quests.QuestsData) do
			if (v.id == id) then
				return v
			end
		end
	end
	return false
end

---@param quest QuestData
---@param progress integer
---@return nil
function Quests:setQuestProgress(quest, progress)
	quest.progress = quest.requirement < progress and quest.requirement or progress
end

---Returns a printable quest name depending on its type
---@param quest QuestData
---@return string
function Quests:getQuestName(quest)
	if (quest.name and quest.name:len() > 1) then
		return quest.name
	end
	if (quest.type == 1) then
		return TB_MENU_LOCALIZED.QUESTSNAMETYPE1
	elseif (quest.type == 2) then
		return TB_MENU_LOCALIZED.QUESTSNAMETYPE2
	elseif (quest.type == 3) then
		return TB_MENU_LOCALIZED.QUESTSNAMETYPE3
	elseif (quest.type == 4) then
		if (quest.decap) then
			return TB_MENU_LOCALIZED.QUESTSNAMETYPEDECAP
		else
			return TB_MENU_LOCALIZED.QUESTSNAMETYPE4
		end
	end
	return TB_MENU_LOCALIZED.QUESTSDEFAULTQUESTNAME
end

---Returns a printable quest objective depending on its type and requirements
---@param quest QuestData
---@return string
function Quests:getQuestObjective(quest)
	local targetText = ""
	if (quest.type == 1) then
		targetText = TB_MENU_LOCALIZED.QUESTSPLAYREQ .. " " .. quest.requirement .. " " .. (quest.ranked and TB_MENU_LOCALIZED.WORDRANKED .. " " or "") .. TB_MENU_LOCALIZED.WORDGAMES
	elseif (quest.type == 2) then
		targetText = TB_MENU_LOCALIZED.QUESTSWINREQ .. " " .. quest.requirement .. " " .. (quest.ranked and TB_MENU_LOCALIZED.WORDRANKED .. " " or "") .. TB_MENU_LOCALIZED.WORDFIGHTS
		if (quest.decap) then
			targetText = targetText .. " " .. TB_MENU_LOCALIZED.QUESTSBYDECAP .. (quest.ranked and " " .. TB_MENU_LOCALIZED.QUESTSRANKEDMODE or "")
		end
	elseif (quest.type == 3) then
		targetText = TB_MENU_LOCALIZED.QUESTSGETREQ .. " " .. quest.requirement .. " " .. TB_MENU_LOCALIZED.QUESTSGETREQ2 .. (quest.ranked and " " .. TB_MENU_LOCALIZED.QUESTSRANKEDMODE or "")
	elseif (quest.type == 4) then
		if (quest.decap) then
			targetText = TB_MENU_LOCALIZED.QUESTSDECAPREQ .. " " .. quest.requirement .. " " .. TB_MENU_LOCALIZED.WORDTIMES .. (quest.ranked and " " .. TB_MENU_LOCALIZED.QUESTSRANKEDMODE or "")
		else
			targetText = TB_MENU_LOCALIZED.QUESTSDISMEMBERREQ .. " " .. quest.requirement .. " " .. TB_MENU_LOCALIZED.WORDTIMES .. (quest.ranked and " " .. TB_MENU_LOCALIZED.QUESTSRANKEDMODE or "")
		end
	end
	if (quest.modid ~= 0) then
		targetText = targetText .. " " .. TB_MENU_LOCALIZED.WORDIN .. " " .. quest.modname
	end
	if (quest.matchmake) then
		targetText = targetText .. " " .. TB_MENU_LOCALIZED.QUESTSMATCHMAKEREQ
	elseif (quest.official) then
		targetText = targetText .. " " .. TB_MENU_LOCALIZED.QUESTSOFFICIALREQ
	end
	return targetText
end

---Returns a printable quest reward name
---@param quest QuestData
---@return string
function Quests:getReward(quest)
	if (quest.rewardid == 0) then
		return quest.reward .. " " .. TB_MENU_LOCALIZED.WORDTC
	end
	local item = Torishop:getItemInfo(quest.rewardid)
	return item.shortname or "???"
end

---Displays quest reward in a specified UIElement viewport
---@param quest QuestData
---@param viewElement UIElement
---@return nil
function Quests:drawRewardText(quest, viewElement)
	local rewardText = Quests:getReward(quest)
	if (rewardText) then
		local iconSize = viewElement.size.h > 32 and 32 or viewElement.size.h
		local questRewardText = viewElement:addChild({
			pos = { iconSize + 20, 0 },
			size = { viewElement.size.w - iconSize - 20, viewElement.size.h }
		})
		questRewardText:addAdaptedText(true, rewardText)
		local textWidth = 0
		for i,v in pairs(questRewardText.dispstr) do
			local w = questRewardText.textScale * get_string_length(v, FONTS.MEDIUM)
			if (w > textWidth) then
				textWidth = w
			end
		end

		local questRewardIcon = viewElement:addChild({
			pos = { (viewElement.size.w - textWidth - iconSize - 10) / 2, (viewElement.size.h - iconSize) / 2 },
			size = { iconSize, iconSize },
			bgImage = quest.rewardid ~= nil and (quest.rewardid == 0 and "../textures/store/toricredit_tiny.tga" or "../textures/store/items/" .. quest.rewardid .. ".tga") or nil
		})
	end
end

---Displays quest information in a UIElement viewport
---@param questView UIElement
---@param quest QuestData
---@param bottomSmudge UIElement Bottom smudge UIElement generated by TBMenu:addBottomBloodSmudge()
---@param customClaimFunc? function Custom function that will be executed after successful quest claiming
---@return nil
function Quests:showQuest(questView, quest, bottomSmudge, customClaimFunc)
	local bgScale = questView.size.w - 20 > questView.size.h / 5 * 3 - 20 and questView.size.h / 5 * 3 - 20 or questView.size.w - 20
	local questBackground = UIElement:new({
		parent = questView,
		pos = { (questView.size.w - bgScale) / 2, 10 },
		size = { bgScale, bgScale },
		bgColor = TB_MENU_DEFAULT_DARKEST_COLOR,
		shapeType = ROUNDED,
		rounded = bgScale
	})
	local qType = (quest.type == 4 and quest.decap) and "decap" or quest.type
	local questIcon = UIElement:new({
		parent = questBackground,
		pos = { bgScale / 5, bgScale / 5 },
		size = { bgScale / 5 * 3, bgScale / 5 * 3 },
		bgImage = "../textures/menu/general/quests/qtype" .. qType .. ".tga"
	})
	local progress = quest.progress / quest.requirement
	progress = progress > 1 and 1 or progress
	questBackground:addCustomDisplay(false, function()
			set_color(unpack(TB_MENU_DEFAULT_LIGHTER_COLOR))
			draw_disk(questBackground.pos.x + questBackground.size.w / 2, questBackground.pos.y + questBackground.size.h / 2, questBackground.size.h / 2 - 25, questBackground.size.h / 2 - 5, 100, 1, -60, -240, 0)
			set_color(unpack(UICOLORWHITE))
			draw_disk(questBackground.pos.x + questBackground.size.w / 2, questBackground.pos.y + questBackground.size.h / 2, questBackground.size.h / 2 - 25, questBackground.size.h / 2 - 5, 100, 1, -60, -240 * progress, 0)
		end)
	if (quest.timeleft < 0) then
		local progressText = UIElement:new({
			parent = questBackground,
			pos = { questBackground.size.w / 5, -questBackground.size.h / 5 },
			size = { questBackground.size.w / 5 * 3, questBackground.size.h / 8 }
		})
		progressText:addAdaptedText(true, quest.progress .. " / " .. quest.requirement)
	else
		quest.timetick = quest.timetick or os.time()
		local progressText = UIElement:new({
			parent = questBackground,
			pos = { questBackground.size.w / 5, -questBackground.size.h / 3 },
			size = { questBackground.size.w / 5 * 3, questBackground.size.h / 8 },
			bgColor = table.clone(TB_MENU_DEFAULT_DARKEST_COLOR)
		})
		progressText.bgColor[4] = 0.7
		progressText:addAdaptedText(false, quest.progress .. " / " .. quest.requirement)
		local timeleftText = UIElement:new({
			parent = questBackground,
			pos = { questBackground.size.w / 5, -questBackground.size.h / 5 },
			size = { questBackground.size.w / 5 * 3, questBackground.size.h / 7 }
		})
		timeleftText:addAdaptedText(true, TBMenu:getTime(quest.timeleft - (os.time() - quest.timetick), 2) .. " " .. TB_MENU_LOCALIZED.TIMELEFT)
		timeleftText:addCustomDisplay(true, function()
				timeleftText:uiText(TBMenu:getTime(quest.timeleft - (os.time() - quest.timetick), 2) .. " " .. TB_MENU_LOCALIZED.TIMELEFT, nil, nil, nil, nil, timeleftText.textScale)
			end)
	end
	local questName = UIElement:new({
		parent = questView,
		pos = { 10, questView.size.h / 5 * 3 },
		size = { questView.size.w - 20, questView.size.h / 10 }
	})
	questName:addAdaptedText(true, Quests:getQuestName(quest), nil, nil, FONTS.BIG, nil, 0.7)
	local questTarget = UIElement:new({
		parent = questView,
		pos = { 10, questView.size.h / 10 * 7 },
		size = { questView.size.w - 20, questView.size.h / 5 }
	})
	questTarget:addAdaptedText(true, Quests:getQuestObjective(quest))
	if (TB_STORE_DATA.ready) then
		local questReward = UIElement:new({
			parent = questView,
			pos = { 5, questView.size.h / 10 * 9 },
			size = { questView.size.w - 10, questView.size.h / 10 }
		})
		Quests:drawRewardText(quest, questReward)
	end
	if (quest.progress >= quest.requirement) then
		local questClaimBg = UIElement:new({
			parent = questView,
			pos = { 0, 0 },
			size = { questView.size.w, questView.size.h },
			bgColor = { 0, 0, 0, 0.2 }
		})
		local questClaim = UIElement:new({
			parent = questClaimBg,
			pos = { 10, (questClaimBg.size.h + 32) / 3 },
			size = { questClaimBg.size.w - 20, (questClaimBg.size.h + 32) / 3 },
			shapeType = ROUNDED,
			rounded = 5,
			innerShadow = { 0, 5 },
			shadowColor = TB_MENU_DEFAULT_ORANGE,
			bgColor = TB_MENU_DEFAULT_YELLOW,
			interactive = true,
			pressedColor = { 0.902, 0.738, 0.269, 1 },
			hoverColor = { 0.969, 0.781, 0.199, 1 }
		})
		questClaim:addMouseHandlers(nil, function()
				questView:kill(true)
				TBMenu:addBottomBloodSmudge(questView, 1)
				TBMenu:displayLoadingMark(questView, "Claiming Quest")
				Request:queue(function() claim_quest(quest.id) end, "questclaim", function()
					update_tc_balance()
					Quests:download()
					download_inventory()

					if (customClaimFunc) then
						customClaimFunc()
					else
						Quests:showMain()
					end
				end)
			end)
		local claimText = UIElement:new({
			parent = questClaim,
			pos = { 10, 0 },
			size = { questClaim.size.w - 20, questClaim.size.h / 2 }
		})
		claimText:addAdaptedText(false, TB_MENU_LOCALIZED.QUESTSCLAIMREWARD, nil, nil, FONTS.BIG, nil, 0.7, nil, nil, 1.8)
		local buttonSize = questClaim.size.h - 15 > 40 and 40 or questClaim.size.h - 15
		local claimButton = UIElement:new({
			parent = questClaim,
			pos = { 10, -5 - (questClaim.size.h / 2 + buttonSize) / 2 },
			size = { questClaim.size.w - 20, buttonSize },
			shapeType = ROUNDED,
			rounded = 5,
			bgColor = { 0.594, 0.418, 0.14, 1 }
		})
		if (TB_STORE_DATA.ready) then
			Quests:drawRewardText(quest, claimButton)
		end
		bottomSmudge:reload()
	end
end

function Quests:requiresGlobalDataUpdate()
	return not Quests.QuestsGlobalData or QUESTS_LASTUPDATE_GLOBAL.time + 300 < os.time() or QUESTS_LASTUPDATE_GLOBAL.qi ~= TB_MENU_PLAYER_INFO.data.qi
end

function Quests:downloadGlobal()
	-- If QuestsGlobalData is present, make sure we don't queue data updates too frequently
	if (not Quests:requiresGlobalDataUpdate()) then
		Quests:getGlobalQuests()
		return false
	end

	download_global_quests()
	return true
end

---Parses global quest information from the quests_global data file
---@param fileData? File File object created by Files:open(). If nil, default path for global quests will be used.
---@return nil
function Quests:getGlobalQuests(fileData)
	TB_MENU_QUESTS_GLOBAL_COUNT = 0
	local fileData = fileData or Files:open("../data/quests_global.dat")

	if (not fileData.data) then
		QUESTS_LASTUPDATE_GLOBAL.time = 0
		Quests:downloadGlobal()
		Quests.QuestDataErrors = Quests.QuestDataErrors + 1
		return
	end

	---@type QuestData[]
	local globalQuests = {}
	local dataTypes = {
		{ 'id', numeric = true },
		{ 'type', numeric = true },
		{ 'name' },
		{ 'requirement', numeric = true },
		{ 'progress', numeric = true },
		{ 'modid', numeric = true },
		{ 'claimed', boolean = true },
		{ 'available', boolean = true },
		{ 'rewardid', numeric = true },
		{ 'reward', numeric = true },
		{ 'description' }
	}
	for i, ln in pairs(fileData:readAll()) do
		if (not string.match(ln, "^questid")) then
			local _, segments = ln:gsub("\t", "")
			local data_stream = { ln:match(("([^\t]*)\t?"):rep(segments)) }

			---@type QuestData
			local quest = {}
			for i,v in pairs(dataTypes) do
				quest[v[1]] = data_stream[i]
				if (v.numeric) then
					quest[v[1]] = tonumber(quest[v[1]]) or 0
				end
				if (v.boolean) then
					quest[v[1]] = quest[v[1]] == '1'
				end
			end
			quest.global = true
			quest.description = quest.description ~= '' and quest.description or false
			quest.progresspercentage = (quest.requirement / (quest.progress == 0 and 0.01 or quest.progress))
			table.insert(globalQuests, quest)

			if (quest.progresspercentage <= 1 and not quest.claimed) then
				TB_MENU_QUESTS_GLOBAL_COUNT = TB_MENU_QUESTS_GLOBAL_COUNT + 1
			end
		end
	end

	fileData:close()

	Quests.QuestsGlobalData = qsort(globalQuests, { "type", "progresspercentage" })
	QUESTS_LASTUPDATE_GLOBAL.time = os.time()
	QUESTS_LASTUPDATE_GLOBAL.qi = TB_MENU_PLAYER_INFO.data.qi
end

---Returns navigation data for legacy Global Quests screen
---@deprecated
---@return MenuNavButton[]
function Quests:getGlobalQuestsNavigation()
	return {
		{
			text = TB_MENU_LOCALIZED.NAVBUTTONBACK,
			action = function() TBMenu:clearNavSection() Notifications:showMain(true) end
		},
		{
			text = TB_MENU_LOCALIZED.QUESTSGLOBALCOMPLETED,
			action = function() Quests:showGlobalQuests(Quests.QuestsGlobalData, true) end,
			right = true,
			sectionId = 2
		},
		{
			text = TB_MENU_LOCALIZED.QUESTSGLOBALACTIVE,
			action = function() Quests:showGlobalQuests(Quests.QuestsGlobalData) end,
			right = true,
			sectionId = 1
		},
	}
end

---Prepares global quests display screen and shows them when ready
---@deprecated
---@return nil
function Quests:prepareGlobalQuests()
	TB_MENU_SPECIAL_SCREEN_ISOPEN = 0
	tbMenuCurrentSection:kill(true)
	TBMenu:clearNavSection()
	TBMenu:showNavigationBar(Quests:getGlobalQuestsNavigation(), true, true, 1)

	if (QUESTS_LASTUPDATE_GLOBAL.time + 60 >= os.time() or QUESTS_LASTUPDATE_GLOBAL.qi == TB_MENU_PLAYER_INFO.data.qi) then
		-- Not enough time has passed or they haven't played any games so progress should be same
		Quests:showGlobalQuests(Quests.QuestsGlobalData)
		return
	end

	download_global_quests()
	local loader = UIElement:new({
		parent = tbMenuCurrentSection,
		pos = { 5, 0 },
		size = { tbMenuCurrentSection.size.w - 10, tbMenuCurrentSection.size.h },
		bgColor = TB_MENU_DEFAULT_BG_COLOR
	})
	TBMenu:addBottomBloodSmudge(loader, 1)
	TBMenu:displayLoadingMark(loader, TB_MENU_LOCALIZED.QUESTSGLOBALUPDATING)

	local questsFile = Files:open("../data/quests_global.dat")
	loader:addCustomDisplay(false, function()
			if (questsFile:isDownloading()) then
				return
			end

			questsFile:reopen()
			Quests:getGlobalQuests(questsFile)
			Quests:showGlobalQuests(Quests.QuestsGlobalData)
		end)
end

---Displays a horizontal quest button
---@param quest QuestData
---@param listingHolder UIElement Listing holder generated by TBMenu:prepareScrollableList()
---@param listElements UIElement[] List of elements added to `listingHolder`
---@param elementHeight number
---@return nil
function Quests:showQuestButton(quest, listingHolder, listElements, elementHeight)
	local questHolder = UIElement:new({
		parent = listingHolder,
		pos = { 0, #listElements * elementHeight },
		size = { listingHolder.size.w, elementHeight }
	})
	table.insert(listElements, questHolder)
	local questBackground = UIElement:new({
		parent = questHolder,
		pos = { 10, 3 },
		size = { questHolder.size.w - 12, questHolder.size.h - 3 },
		bgColor = TB_MENU_DEFAULT_DARKER_COLOR,
		shapeType = ROUNDED,
		rounded = { 4, 0 }
	})
	if (not quest.description) then
		questBackground.size.h = questBackground.size.h - 3
		questBackground:setRounded(4)
	end
	local questTitle = UIElement:new({
		parent = questBackground,
		pos = { 10, 5 },
		size = { questBackground.size.w / 4, questBackground.size.h - 10 }
	})
	questTitle:addAdaptedText(true, quest.name, nil, nil, nil, LEFTMID)

	local questProgress = quest.progress > quest.requirement and 1 or quest.progress / quest.requirement
	local questProgressOutline = UIElement:new( {
		parent = questBackground,
		pos = { questTitle.shift.x + questTitle.size.w + 10, 10 },
		size = { questBackground.size.w / 2 - 20, questBackground.size.h - 20 },
		bgColor = TB_MENU_DEFAULT_DARKEST_COLOR,
		shapeType = ROUNDED,
		rounded = 10
	})
	local questProgressBar = UIElement:new({
		parent = questProgressOutline,
		pos = { 2, 2 },
		size = { questProgressOutline.size.w - 4, questProgressOutline.size.h - 4 },
		bgColor = TB_MENU_DEFAULT_DARKER_COLOR,
		shapeType = questProgressOutline.shapeType,
		rounded = questProgressOutline.rounded / 5 * 4
	})
	local questProgressBarState
	if (quest.progress > 0) then
		questProgressBarState = UIElement:new({
			parent = questProgressBar,
			pos = { 0, 0 },
			size = { questProgressBar.size.w * questProgress, questProgressBar.size.h },
			shapeType = questProgressBar.shapeType,
			rounded = questProgressBar.rounded,
			interactive = questProgress == 1 and not quest.claimed,
			bgColor = (quest.progresspercentage > 1 or quest.claimed) and TB_MENU_DEFAULT_BG_COLOR or TB_MENU_DEFAULT_ORANGE,
			hoverColor = TB_MENU_DEFAULT_DARKER_ORANGE,
			pressedColor = TB_MENU_DEFAULT_YELLOW,
			innerShadow = { 3, 3 },
			shadowColor = { (quest.progresspercentage > 1 or quest.claimed) and TB_MENU_DEFAULT_LIGHTER_COLOR or TB_MENU_DEFAULT_YELLOW, (quest.progresspercentage > 1 or quest.claimed) and TB_MENU_DEFAULT_DARKEST_COLOR or TB_MENU_DEFAULT_DARKER_ORANGE }
		})
	end
	local questProgressText = UIElement:new({
		parent = questProgressBar,
		pos = { questProgressBar.size.w / 3, 3 },
		size = { questProgressBar.size.w / 3, questProgressBar.size.h - 6 }
	})
	if (questProgress < 1) then
		questProgressText:addAdaptedText(true, quest.progress .. " / " .. quest.requirement, nil, nil, nil, nil, nil, nil, nil, 1)
	elseif (quest.claimed) then
		questProgressText:addAdaptedText(true, TB_MENU_LOCALIZED.REWARDSCLAIMSUCCESS, nil, nil, nil, nil, nil, nil, nil, 1)
	else
		questProgressText:addAdaptedText(true, TB_MENU_LOCALIZED.QUESTSCLAIMREWARD, nil, nil, nil, nil, nil, nil, nil, 1)
		questProgressBarState:addMouseHandlers(nil, function()
				questProgressBarState:deactivate(true)
				questProgressText:addCustomDisplay(true, function() end)
				TBMenu:displayLoadingMarkSmall(questProgressBarState, "", questProgressText.textFont)
				Request:queue(function() claim_quest_global(quest.id) end, "net_questclaim", function()
						questProgressBarState:kill(true)
						local response = get_network_response()
						if (response:find("GATEWAY 0; 0")) then
							update_tc_balance()
							download_inventory()

							TB_MENU_QUESTS_GLOBAL_COUNT = math.max(0, TB_MENU_QUESTS_GLOBAL_COUNT - 1)
							quest.claimed = true
							questProgressBarState.bgColor = TB_MENU_DEFAULT_DARKER_COLOR
							questProgressBarState.inactiveColor = TB_MENU_DEFAULT_DARKER_COLOR
							questProgressBarState.shadowColor = { TB_MENU_DEFAULT_LIGHTER_COLOR, TB_MENU_DEFAULT_DARKEST_COLOR }
							questProgressText:addAdaptedText(true, TB_MENU_LOCALIZED.REWARDSCLAIMSUCCESS, nil, nil, nil, nil, nil, nil, nil, 1)
						else
							TBMenu:showDataError(TB_MENU_LOCALIZED.ERRORTRYAGAIN)
							questProgressBarState:activate()
							questProgressText:addAdaptedText(true, TB_MENU_LOCALIZED.QUESTSCLAIMREWARD, nil, nil, nil, nil, nil, nil, nil, 1)
						end
					end, function()
						questProgressBarState:kill(true)
						TBMenu:showDataError(TB_MENU_LOCALIZED.REWARDSCLAIMNETWORKERROR)
						questProgressBarState:activate()
						questProgressText:addAdaptedText(true, TB_MENU_LOCALIZED.QUESTSCLAIMREWARD, nil, nil, nil, nil, nil, nil, nil, 1)
					end)
			end)
	end

	local rewardText = quest.rewardid == 0 and (quest.reward .. " " .. TB_MENU_LOCALIZED.WORDTORICREDITS) or (quest.rewardid == ITEM_SHIAI_TOKEN and (quest.reward .. " " .. TB_MENU_LOCALIZED.WORDSHIAITOKENS) or Torishop:getItemInfo(quest.rewardid).itemname)
	if (rewardText ~= "") then
		local questRewardText = UIElement:new({
			parent = questBackground,
			pos = { questProgressOutline.shift.x + questProgressOutline.size.w + 10, questTitle.shift.y },
			size = { questBackground.size.w - questProgressOutline.size.w - questProgressOutline.shift.x - 30 - questTitle.size.h, questTitle.size.h }
		})
		questRewardText:addAdaptedText(true, TB_MENU_LOCALIZED.WORDREWARD ..  ": " .. rewardText, nil, nil, 4, RIGHTMID, 0.7)
		local rewardIcon = quest.rewardid == 0 and "../textures/store/toricredit.tga" or (quest.rewardid == ITEM_SHIAI_TOKEN and "../textures/store/shiaitoken.tga" or Torishop:getItemIcon(quest.rewardid))
		local questRewardIcon = UIElement:new({
			parent = questBackground,
			pos = { questRewardText.shift.x + questRewardText.size.w + 10, 5 },
			size = { questBackground.size.h - 10, questBackground.size.h - 10 },
			bgImage = rewardIcon
		})
	end

	if (quest.description) then
		local questDescHolder = UIElement:new({
			parent = listingHolder,
			pos = { 0, #listElements * elementHeight },
			size = { listingHolder.size.w, elementHeight }
		})
		table.insert(listElements, questDescHolder)
		local questDescBackground = UIElement:new({
			parent = questDescHolder,
			pos = { 10, 0 },
			size = { questDescHolder.size.w - 12, questDescHolder.size.h - 3 },
			bgColor = TB_MENU_DEFAULT_DARKER_COLOR,
			shapeType = ROUNDED,
			rounded = { 0, 4 }
		})
		local questDescText = UIElement:new({
			parent = questDescBackground,
			pos = { 10, 5 },
			size = { questDescBackground.size.w - 20, questDescBackground.size.h - 10 }
		})
		questDescText:addAdaptedText(true, quest.description, nil, nil, 4, LEFT, 0.7)
	end
end

---@deprecated
---Use Quests:showQuestButton() instead
---@param quest QuestData
---@param listingHolder UIElement
---@param listElements UIElement[]
---@param elementHeight number
---@return nil
function Quests:showGlobalQuestButton(quest, listingHolder, listElements, elementHeight)
	Quests:showQuestButton(quest, listingHolder, listElements, elementHeight)
end

---@deprecated
---@param questsData QuestData[]
---@param completed? boolean Whether we're showing completed quests or those still in progress
---@return nil
function Quests:showGlobalQuests(questsData, completed)
	usage_event("questsglobal")
	tbMenuCurrentSection:kill(true)
	local completed = completed or false

	local elementHeight = 60
	local mainHolder = UIElement:new({
		parent = tbMenuCurrentSection,
		pos = { 5, 0 },
		size = { tbMenuCurrentSection.size.w - 10, tbMenuCurrentSection.size.h },
		bgColor = TB_MENU_DEFAULT_BG_COLOR
	})
	local toReload, topBar, botBar, listingView, listingHolder, listingScrollBG = TBMenu:prepareScrollableList(mainHolder, elementHeight, elementHeight - 16, 20, TB_MENU_DEFAULT_BG_COLOR)

	local questsHeader = UIElement:new({
		parent = topBar,
		pos = { 15, 13 },
		size = { topBar.size.w - 30, topBar.size.h - 26 }
	})
	questsHeader:addAdaptedText(true, TB_MENU_LOCALIZED.QUESTSGLOBAL, nil, nil, FONTS.BIG, LEFTMID)
	TBMenu:addBottomBloodSmudge(botBar)

	local listElements = {}
	local shownQuests = { count = 0 }
	local shownSections = {}

	if (not completed) then
		local availableQuests = 0
		local closestAndAvailableQuests = UIElement:new({
			parent = listingHolder,
			pos = { 20, #listElements * elementHeight },
			size = { listingHolder.size.w - 40, elementHeight }
		})
		closestAndAvailableQuests:addAdaptedText(false, TB_MENU_LOCALIZED.QUESTSCLOSEST, nil, nil, nil, LEFTMID)
		table.insert(listElements, closestAndAvailableQuests)
		for i, quest in pairs(UIElement:qsort(questsData, { "progresspercentage", "requirement" })) do
			if (quest.available and not quest.claimed) then
				availableQuests = availableQuests + 1
				if (not shownSections[quest.type]) then
					Quests:showGlobalQuestButton(quest, listingHolder, listElements, elementHeight)
					shownQuests[quest.id] = true
					if (quest.modreq == 0) then
						shownSections[quest.type] = true
					else
						shownSections[quest.type] = {}
						shownSections[quest.type][quest.modreq] = true
					end
					shownQuests.count = shownQuests.count + 1
				elseif (quest.progress > quest.requirement) then
					Quests:showGlobalQuestButton(quest, listingHolder, listElements, elementHeight)
					shownQuests[quest.id] = true
					shownQuests.count = shownQuests.count + 1
				elseif (type(shownSections[quest.type]) == "table") then
					if (not shownSections[quest.type][quest.modreq]) then
						Quests:showGlobalQuestButton(quest, listingHolder, listElements, elementHeight)
						shownQuests[quest.id] = true
						shownSections[quest.type][quest.modreq] = true
						shownQuests.count = shownQuests.count + 1
					end
				end
			end
		end
		if (shownQuests.count == 0) then
			closestAndAvailableQuests:kill()
			table.remove(listElements)
		end
		if (shownQuests.count < availableQuests) then
			local lockedQuestsSeparator = UIElement:new({
				parent = listingHolder,
				pos = { 0, #listElements * elementHeight },
				size = { listingHolder.size.w, elementHeight }
			})
			lockedQuestsSeparator:addCustomDisplay(true, function() end)
			table.insert(listElements, lockedQuestsSeparator)
			local lockedQuests = UIElement:new({
				parent = listingHolder,
				pos = { 20, #listElements * elementHeight },
				size = { listingHolder.size.w - 40, elementHeight }
			})
			lockedQuests:addAdaptedText(false, TB_MENU_LOCALIZED.QUESTSLOCKED, nil, nil, nil, LEFTMID)
			table.insert(listElements, lockedQuests)
		end
	end

	for i, quest in pairs(questsData) do
		if (completed == quest.claimed and not shownQuests[quest.id] and (quest.claimed or quest.available)) then
			Quests:showGlobalQuestButton(quest, listingHolder, listElements, elementHeight)
		end
	end

	if (#listElements == 0) then
		listingHolder:addAdaptedText(true, TB_MENU_LOCALIZED.NOTHINGTOSHOW)
		return
	end

	for i,v in pairs(listElements) do
		v:hide()
	end
	local scrollBar = TBMenu:spawnScrollBar(listingHolder, #listElements, elementHeight)
	scrollBar:makeScrollBar(listingHolder, listElements, toReload)
end

---Displays the legacy Quests screen
---@deprecated
---@return nil
function Quests:showQuestsLegacy()
	tbMenuCurrentSection:kill(true)
	local tbMenuCurrentSection = tbMenuCurrentSection:addChild({ shift = { 0, 0 }})
	local globalQuests = UIElement:new({
		parent = tbMenuCurrentSection,
		pos = { 5, 0 },
		size = { tbMenuCurrentSection.size.w / 7 * 2 - 10, tbMenuCurrentSection.size.h },
		bgColor = TB_MENU_DEFAULT_BG_COLOR,
		interactive = true,
		hoverColor = TB_MENU_DEFAULT_DARKER_COLOR,
		pressedColor = TB_MENU_DEFAULT_DARKEST_COLOR,
		hoverSound = 31
	})

	local questsToClaimIcon = nil
	if (TB_MENU_QUESTS_GLOBAL_COUNT > 0) then
		questsToClaimIcon = UIElement:new({
			parent = globalQuests,
			pos = { globalQuests.size.w / 6, globalQuests.size.h / 7 * 2 },
			size = { globalQuests.size.w / 5, globalQuests.size.w / 5 },
			shapeType = ROUNDED,
			rounded = globalQuests.size.w / 5,
			bgColor = TB_MENU_DEFAULT_BG_COLOR
		})
		questsToClaimIcon:addCustomDisplay(false, function()
				questsToClaimIcon:uiText("!", nil, nil, FONTS.BIG)
			end)
	end
	TBMenu:showHomeButton(globalQuests, {
			title = TB_MENU_LOCALIZED.QUESTSGLOBAL,
			subtitle = TB_MENU_LOCALIZED.QUESTSGLOBALDESC,
			ratio = 1,
			image = "../textures/menu/modmaker.tga",
			mode = ORIENTATION_PORTRAIT,
			action = function()
					Quests:prepareGlobalQuests()
				end
		}, 1, questsToClaimIcon)
	if (questsToClaimIcon) then
		questsToClaimIcon:hide()
		questsToClaimIcon:show()
	end

	local questsHolderWidth = math.max(tbMenuCurrentSection.size.w - globalQuests.size.w - globalQuests.shift.x - 5, #Quests.QuestsData * WIN_H / 3)
	local questsHolder = UIElement:new({
		parent = tbMenuCurrentSection,
		pos = { globalQuests.size.w + globalQuests.shift.x + 5, 0 },
		size = { questsHolderWidth, tbMenuCurrentSection.size.h }
	})
	if (Quests.QuestsData) then
		for i, quest in pairs(Quests.QuestsData) do
			local questView = UIElement:new({
				parent = questsHolder,
				pos = { 5 + (i - 1) * questsHolder.size.w / #Quests.QuestsData, 0 },
				size = { questsHolder.size.w / #Quests.QuestsData - 10, questsHolder.size.h },
				bgColor = TB_MENU_DEFAULT_BG_COLOR
			})
			local bottomSmudge = TBMenu:addBottomBloodSmudge(questView, i)
			Quests:showQuest(questView, quest, bottomSmudge)
		end
		if (tbMenuCurrentSection.size.w - globalQuests.size.w - globalQuests.shift.x - 5 < questsHolderWidth) then
			local scrollRight = TBMenu:createImageButtons(tbMenuCurrentSection.parent, tbMenuCurrentSection.shift.x + tbMenuCurrentSection.size.w - 32, tbMenuCurrentSection.shift.y + tbMenuCurrentSection.size.h / 2 - 32, 32, 64, "../textures/menu/general/buttons/arrowright.tga", nil, nil, { 0, 0, 0, 0.4 }, { 0, 0, 0, 0.7 }, { 0, 0, 0, 0.6 }, 8)
			local scrollLeft = TBMenu:createImageButtons(tbMenuCurrentSection.parent, 0, tbMenuCurrentSection.shift.y + tbMenuCurrentSection.size.h / 2 - 32, 32, 64, "../textures/menu/general/buttons/arrowleft.tga", nil, nil, { 0, 0, 0, 0.4 }, { 0, 0, 0, 0.7 }, { 0, 0, 0, 0.6 }, 8)

			scrollRight:addMouseHandlers(nil, function()
					local animator = tbMenuCurrentSection:addChild({ shift = { 0, 0 } })
					local targetPoint = _G.tbMenuCurrentSection.pos.x + tbMenuCurrentSection.size.w
					animator:addCustomDisplay(true, function()
						scrollRight:hide()
						if (questsHolder.pos.x - 50 + questsHolder.size.w < targetPoint) then
							tbMenuCurrentSection:moveTo(-questsHolder.shift.x - questsHolder.size.w)
							animator:kill()
							scrollLeft:show()
						else
							tbMenuCurrentSection:moveTo(-50, nil, true)
						end
					end)
				end, nil)
			scrollLeft:addMouseHandlers(nil, function()
					local animator = tbMenuCurrentSection:addChild({ shift = { 0, 0 } })
					local targetPoint = _G.tbMenuCurrentSection.pos.x
					animator:addCustomDisplay(true, function()
						scrollLeft:hide()
						if (tbMenuCurrentSection.pos.x + 50 > targetPoint) then
							tbMenuCurrentSection:moveTo(0)
							animator:kill()
							scrollRight:show()
						else
							tbMenuCurrentSection:moveTo(50, nil, true)
						end
					end)
				end, nil)
		scrollLeft:hide()
		end
	else
		local questView = UIElement:new({
			parent = questsHolder,
			pos = { 5, 0 },
			size = { questsHolder.size.w - 10, questsHolder.size.h },
			bgColor = TB_MENU_DEFAULT_BG_COLOR
		})
		TBMenu:addBottomBloodSmudge(questView, i)
		questView:addAdaptedText(false, TB_MENU_LOCALIZED.NOTHINGTOSHOW)
	end
end

---Displays Quests screen home. If quests data is missing, queues download and shows loading screen first.
---@deprecated
---@param reload? boolean
---@return nil
function Quests:showMainLegacy(reload)
	usage_event("quests")
	tbMenuCurrentSection:kill(true)
	if (Quests.QuestsData and not reload) then
		Quests:showQuestsLegacy()
	else
		if (reload) then
			Quests:download()
		end
		local waitView = UIElement:new({
			parent = tbMenuCurrentSection,
			pos = { 5, 0 },
			size = { tbMenuCurrentSection.size.w - 10, tbMenuCurrentSection.size.h },
			bgColor = TB_MENU_DEFAULT_BG_COLOR
		})
		TBMenu:addBottomBloodSmudge(waitView, 1)
		waitView:addCustomDisplay(false, function()
				waitView:uiText(TB_MENU_LOCALIZED.QUESTSUPDATING)
				if (Quests.QuestsData) then
					if (waitView and not waitView.destroyed) then
						Quests:showQuestsLegacy()
					end
				end
			end)
	end
end

---Displays the list of player's quests
---@param viewElement UIElement
---@param questsData table
---@return nil
function Quests:showMainQuestList(viewElement, questsData)
	viewElement:kill(true)

	local elementHeight = 60
	local toReload, topBar, botBar, listingView, listingHolder, scrollBackground = TBMenu:prepareScrollableList(viewElement, 70, elementHeight, 20, TB_MENU_DEFAULT_BG_COLOR)

	topBar:addChild({ shift = { 20, 5 }}):addAdaptedText(questsData.name, nil, nil, FONTS.BIG, nil, 0.7)
	local listElements = {}
	for i,v in pairs(questsData.quests) do
		Quests:showQuestButton(v, listingHolder, listElements, elementHeight)
	end
	for i,v in pairs(listElements) do
		v:hide()
	end
	if (#listElements * elementHeight > listingHolder.size.h) then
		for i,v in pairs(listElements) do
			v:hide()
		end

		local scrollBar = TBMenu:spawnScrollBar(listingHolder, #listElements, elementHeight)
		listingHolder.scrollBar = scrollBar
		scrollBar:makeScrollBar(listingHolder, listElements, toReload)
	else
		listingHolder:moveTo((listingHolder.parent.size.w - listingHolder.size.w) / 4, nil, true)
	end
end

---Internal function to display quest type buttons for Quests main screen
---@param listingHolder UIElement
---@param v table
---@param listElements UIElement[]
---@param elementHeight number
---@param listView UIElement Viewport for quests display that will get reloaded on button click
---@return nil
function Quests:displayMainQuestTypeButton(listingHolder, v, listElements, elementHeight, listView)
	if (#v.quests > 0) then
		local listButton = listingHolder:addChild({
			pos = { 0, #listElements * elementHeight },
			size = { listingHolder.size.w, elementHeight }
		})
		table.insert(listElements, listButton)
		local buttonHolder = listButton:addChild({
			pos = { 10, 2 },
			size = { listButton.size.w - 12, listButton.size.h - 4 },
			shapeType = ROUNDED,
			rounded = 4,
			bgColor = v.selected and TB_MENU_DEFAULT_DARKEST_COLOR or TB_MENU_DEFAULT_DARKER_COLOR,
			hoverColor = TB_MENU_DEFAULT_DARKEST_COLOR,
			pressedColor = TB_MENU_DEFAULT_LIGHTER_COLOR,
			interactive = true
		})
		local buttonText = buttonHolder:addChild({
			pos = { 10, 3 },
			size = { buttonHolder.size.w * 0.8 - 15, buttonHolder.size.h - 6 }
		})
		buttonText:addAdaptedText(v.name, nil, nil, 4, LEFTMID, 0.8)
		local buttonQuestsCount = buttonHolder:addChild({
			pos = { -buttonHolder.size.h, 5 },
			size = { buttonHolder.size.h - 10, buttonHolder.size.h - 10 },
			bgColor = TB_MENU_DEFAULT_INACTIVE_COLOR_TRANS,
			shapeType = ROUNDED,
			rounded = buttonHolder.size.h
		})
		buttonQuestsCount:addChild({ shift = { 3, 3 }}):addAdaptedText(#v.quests .. "", nil, nil, 4, nil, 0.7)
		buttonHolder:addMouseUpHandler(function()
				if (listingHolder.selectedButton ~= buttonHolder) then
					listingHolder.selectedButton.bgColor = table.clone(TB_MENU_DEFAULT_DARKER_COLOR)
					listingHolder.selectedButton = buttonHolder
					listingHolder.selectedButton.bgColor = table.clone(TB_MENU_DEFAULT_DARKEST_COLOR)
					Quests:showMainQuestList(listView, v)
				end
			end)

		if (v.selected) then
			listingHolder.selectedButton = buttonHolder
		end
	end
end

---Displays a scrollable list with available quest types
---@param viewElement UIElement
---@param listView UIElement
function Quests:showMainQuestTypes(viewElement, listView)
	local regularQuestList = {
		REGULAR = {
			name = "Repeating Quests",
			quests = {},
			selected = true,
			canBeClaimed = 0
		},
		LIMITED = {
			name = "Limited Quests",
			quests = {},
			canBeClaimed = 0
		},
		RANKED = {
			name = "Ranked Quests",
			quests = {},
			canBeClaimed = 0
		}
	}
	for i,v in pairs(Quests.QuestsData) do
		if (v.timeleft < 0 and v.ranked == false) then
			table.insert(regularQuestList.REGULAR.quests, v)
			if (v.progress >= v.requirement) then
				regularQuestList.REGULAR.canBeClaimed = regularQuestList.REGULAR.canBeClaimed + 1
			end
		else
			if (v.timeleft > 0) then
				table.insert(regularQuestList.LIMITED.quests, v)
				if (v.progress >= v.requirement) then
					regularQuestList.LIMITED.canBeClaimed = regularQuestList.LIMITED.canBeClaimed + 1
				end
			end
			if (v.ranked) then
				table.insert(regularQuestList.RANKED.quests, v)
				if (v.progress >= v.requirement) then
					regularQuestList.RANKED.canBeClaimed = regularQuestList.RANKED.canBeClaimed + 1
				end
			end
		end
	end

	local globalQuestList = {
		{
			name = "Quests in progress",
			quests = {},
			canBeClaimed = 0
		},
		{
			name = "Completed quests",
			quests = {},
			canBeClaimed = 0
		}
	}
	for i,v in pairs(Quests.QuestsGlobalData) do
		if (v.claimed) then
			table.insert(globalQuestList[2].quests, v)
		else
			table.insert(globalQuestList[1].quests, v)
			if (v.progress >= v.requirement) then
				globalQuestList[1].canBeClaimed = globalQuestList[1].canBeClaimed + 1
			end
		end
	end

	local elementHeight = 50
	local toReload, topBar, botBar, listingView, listingHolder, scrollBackground = TBMenu:prepareScrollableList(viewElement, 70, elementHeight, 20, TB_MENU_DEFAULT_BG_COLOR)
	local listElements = {}

	topBar:addChild({ shift = { 10, 5 } }):addAdaptedText(TB_MENU_LOCALIZED.NAVBUTTONQUESTS, nil, nil, FONTS.BIG, nil, 0.7)

	local regularQuestsTitle = listingHolder:addChild({
		pos = { 0, 0 },
		size = { listingHolder.size.w, elementHeight }
	})
	table.insert(listElements, regularQuestsTitle)
	regularQuestsTitle:addChild({ shift = { 15, 5 }}):addAdaptedText(TB_MENU_LOCALIZED.QUESTSREGULAR, nil, nil, FONTS.BIG, LEFTMID)

	for i,v in pairs(regularQuestList) do
		Quests:displayMainQuestTypeButton(listingHolder, v, listElements, elementHeight, listView)
	end

	table.insert(listElements, listingHolder:addChild({
		pos = { 0, #listElements * elementHeight },
		size = { listingHolder.size.w, elementHeight }
	}))

	local globalQuestsTitle = listingHolder:addChild({
		pos = { 0, #listElements * elementHeight },
		size = { listingHolder.size.w, elementHeight }
	})
	table.insert(listElements, globalQuestsTitle)
	globalQuestsTitle:addChild({ shift = { 15, 5 }}):addAdaptedText(TB_MENU_LOCALIZED.QUESTSGLOBAL, nil, nil, FONTS.BIG, LEFTMID)

	for i,v in pairs(globalQuestList) do
		Quests:displayMainQuestTypeButton(listingHolder, v, listElements, elementHeight, listView)
	end

	if (#listElements * elementHeight > listingHolder.size.h) then
		for i,v in pairs(listElements) do
			v:hide()
		end

		local scrollBar = TBMenu:spawnScrollBar(listingHolder, #listElements, elementHeight)
		listingHolder.scrollBar = scrollBar
		scrollBar:makeScrollBar(listingHolder, listElements, toReload)
	else
		listingHolder:moveTo((listingHolder.parent.size.w - listingHolder.size.w) / 4, nil, true)
	end

	Quests:showMainQuestList(listView, regularQuestList.REGULAR)
end

---Displays the main Quests screen
---@return nil
function Quests:showQuests()
	tbMenuCurrentSection:kill(true)
	local questTypesView = tbMenuCurrentSection:addChild({
		pos = { 5, 0 },
		size = { tbMenuCurrentSection.size.w / 4 - 10, tbMenuCurrentSection.size.h },
		bgColor = TB_MENU_DEFAULT_BG_COLOR
	})
	local questListView = tbMenuCurrentSection:addChild({
		pos = { questTypesView.shift.x + questTypesView.size.w + 10, 0 },
		size = { tbMenuCurrentSection.size.w - questTypesView.shift.x - questTypesView.size.w - 15, tbMenuCurrentSection.size.h },
		bgColor = TB_MENU_DEFAULT_BG_COLOR
	})
	Quests:showMainQuestTypes(questTypesView, questListView)
end

---Prepares the main Quests screen for display.\
---If quests data is empty, fetches and parses the data file first.
---@return nil
function Quests:showMain()
	usage_event("quests")
	tbMenuCurrentSection:kill(true)

	if (Quests.QuestsData and not Quests:requiresGlobalDataUpdate()) then
		Quests:showQuests()
		return
	end
	Quests:download()
	Quests:downloadGlobal()
	local updatingView = tbMenuCurrentSection:addChild({
		shift = { 5, 0 },
		bgColor = TB_MENU_DEFAULT_BG_COLOR
	})
	TBMenu:displayLoadingMark(updatingView, TB_MENU_LOCALIZED.QUESTSUPDATING)
	TBMenu:addBottomBloodSmudge(updatingView, 1)
	local spawnClock = os.clock()
	updatingView:addCustomDisplay(function()
			if (Quests.QuestsData and Quests.QuestsGlobalData) then
				Quests:showQuests()
			end
			if (os.clock() - spawnClock > 10 and Quests.QuestDataErrors > 0) then
				updatingView:kill(true)
				updatingView:addAdaptedText(TB_MENU_LOCALIZED.ERRORTRYAGAIN)
				TBMenu:addBottomBloodSmudge(updatingView, 1)
			end
		end)
end
