require("system.menu_backend_defines")
require("toriui.uielement")
require("system.iofiles")
require("system.battlepass_manager")

---@alias QuestDQMode
---| 0 # QUESTS_DQ_ANY | Default
---| 1 # QUESTS_DQ | Win by point score
---| 2 # QUESTS_POINTS | Win by disqualification

---@class QuestData
---@field id integer
---@field global boolean
---@field type integer
---@field progress integer Current quest progress
---@field requirement integer Required quest progress for it to be completed
---@field timeleft integer Time left until quest expiry
---@field modid integer ID of the mod required for quest progression
---@field modname string Name of the mod required for quest progression
---@field decap boolean If true, quest requires the player to decap an opponent during the fight
---@field matchmake boolean If true, quest requires the fight to be played in matchmaking mode
---@field official boolean If true, quest requires the fight to be played in an official (static) room. *Regular quests only*.
---@field dq QuestDQMode Whether this quest requires the fight to end in a specific way
---@field reward integer Reward amount
---@field rewardid integer Item ID of the reward. If zero, `reward` value indicates TC reward.
---@field bp_xp integer Battle Pass XP awarded for completing the quest
---@field name string Custom or autogenerated quest name
---@field ranked boolean If true, quest requires the fight to be played in ranked mode. *Regular quests only*.
---@field claimed boolean Whether the quest has been completed by the user. *Global quests only*.
---@field available boolean Whether the quest is currently available for the user. *Global quests only*.
---@field progresspercentage number Quest progress percentage
---@field description string Additional information about the quest

if (Quests == nil or TB_MENU_DEBUG) then
	-- Quests manager class
	--
	-- **Ver 1.3 updates:**
	-- * Updated visuals to show all quests same as global quests from previous versions
	-- * Quests:showGlobalQuestButton() is now Quests:showQuestButton()
	-- * Battle Pass quests support
	--
	-- **Ver 1.2 updates:**
	-- * Allow scrolling the quests list if there are too many of them to not shrink the buttons by too much
	---@class Quests
	---@field QuestsData QuestData[] Table containing all active regular quests for current user
	---@field QuestsGlobalData QuestData[] Table containing information on all global quests for the user
	---@field QuestDataErrors integer Will be non-zero if quest data file parsing resulted in an error
	Quests = {
		__index = {},
		ver = 1.3,
		QuestsData = nil,
		QuestsGlobalData = nil,
		QuestDataErrors = 0
	}
	setmetatable({}, Quests)
end

---Downloads quests data file and stores last update time to QUESTS_LASTUPDATE.time\
---Will not queue the file for download if it's already in download queue or has been downloaded within past 5 seconds.
---@param override? boolean If true, will force the update even if update clock says it's too early to do so
---@return boolean #Whether file download has been initiated
function Quests:download(override)
	local clock = os.time()
	if (not override and clock - (QUESTS_LASTUPDATE.time or 0) < 5) then
		return false
	end

	local downloads = get_downloads()
	local downloadingQuest, downloadingGlobalQuest
	for i,v in pairs(downloads) do
		if (v:find("quest.txt$")) then
			downloadingQuest = true
		elseif (v:find("quests_global.txt$")) then
			downloadingGlobalQuest = true
		end
	end

	if (downloadingQuest and downloadingGlobalQuest) then
		return false
	end

	QUESTS_LASTUPDATE.time = clock
	if (not downloadingQuest) then
		Quests.QuestsData = nil
		download_quest(TB_MENU_PLAYER_INFO.username)
	end
	if (not downloadingGlobalQuest) then
		Quests:downloadGlobal()
	end
	return true
end

---Parses information about available quests from the data file.\
---If data file is missing, increments Quests.QuestDataErrors and queues it for download.
---@return nil
function Quests:getQuests()
	TB_MENU_QUESTS_COUNT = 0
	local file = Files:open("../data/quest.txt")
	if (not file.data) then
		Quests:download()
		Quests.QuestDataErrors = Quests.QuestDataErrors + 1
	end

	---@type QuestData[]
	local questData = {}
	local dataTypes = {
		{ "id", numeric = true },
		{ "type", numeric = true },
		{ "progress", numeric = true },
		{ "requirement", numeric = true },
		{ "timeleft", numeric = true },
		{ "modid", numeric = true },
		{ "modname" },
		{ "decap", boolean = true },
		{ "matchmake", boolean = true },
		{ "official", boolean = true },
		{ "reward", numeric = true },
		{ "rewardid", numeric = true },
		{ "name" },
		{ "ranked", boolean = true },
		{ "dq", numeric = true },
		{ "bp_xp", numeric = true },
		{ "description" }
	}

	for i, ln in pairs(file:readAll()) do
		if (not ln:find("^#")) then
			local _, segments = ln:gsub("([^\t]*)\t?", "")
			local dataStream = { ln:match(("([^\t]*)\t?"):rep(segments)) }

			---@type QuestData
			local quest = {}
			for i,v in pairs(dataTypes) do
				quest[v[1]] = dataStream[i]
				if (v.numeric) then
					quest[v[1]] = tonumber(quest[v[1]]) or 0
				elseif (v.boolean) then
					quest[v[1]] = quest[v[1]] == '1'
				end
			end
			quest.name = quest.name:len() > 0 and quest.name or Quests:getQuestName(quest)
			quest.description = quest.description:len() > 0 and quest.description or Quests:getQuestObjective(quest)
			quest.progresspercentage = math.min(1, quest.progress / quest.requirement)
			table.insert(questData, quest)

			if (quest.progress >= quest.requirement) then
				-- Handle special quest types
				-- These are claimed automatically upon reaching the objective, so mark them as claimed
				if (quest.type >= 1000) then
					quest.claimed = true
					quest.requirement = quest.progress + 1
				else
					TB_MENU_QUESTS_COUNT = TB_MENU_QUESTS_COUNT + 1
				end
			end
		end
	end
	file:close()

	local loginRewardsAvailable = PlayerInfo:getLoginRewards().available
	if (loginRewardsAvailable) then
		table.insert(questData, {
			id = 2000,
			name = TB_MENU_LOCALIZED.QUESTSDAILYPLAYER,
			description = "Log in and claim login rewards",
			progresspercentage = loginRewardsAvailable and 0 or 1,
			requirement = loginRewardsAvailable and 1 or 2,
			progress = loginRewardsAvailable and 0 or 1,
			claimed = not loginRewardsAvailable,
			type = 0,
			timeleft = -1,
			modid = 0,
			modname = '',
			reward = 0,
			rewardid = 0,
			bp_xp = 5
		})
	end

	---@type QuestData[]
	Quests.QuestsData = table.qsort(questData, "progresspercentage", SORT_DESCENDING)
end

---Updates daily login quest status
---@param completed boolean
---@return boolean
function Quests:updateLoginQuestStatus(completed)
	if (not Quests.QuestsData) then
		return false
	end

	for i,v in pairs(Quests.QuestsData) do
		if (v.id == 2000) then
			Quests.QuestsData[i].requirement = completed and 2 or 1
			Quests.QuestsData[i].progress = completed and 1 or 0
			Quests.QuestsData[i].progresspercentage = completed and 1 or 0
			Quests.QuestsData[i].claimed = completed
			Quests.QuestsData = table.qsort(Quests.QuestsData, "progresspercentage", SORT_DESCENDING)
			return true
		end
	end
	return false
end

---Returns quest data with the matching quest id. If no quest is found, returns `false`.
---@param id integer
---@return QuestData|boolean
function Quests:getQuestById(id)
	if (not Quests.QuestsData) then
		Quests:getQuests()
	end
	if (Quests.QuestsData) then
		for i,v in pairs(Quests.QuestsData) do
			if (v.id == id) then
				return Quests.QuestsData[i]
			end
		end
	end
	return false
end

---@param quest QuestData
---@param progress integer
---@return nil
function Quests:setQuestProgress(quest, progress)
	quest.progress = quest.requirement < progress and quest.requirement or progress
	quest.progresspercentage = quest.progress / quest.requirement
end

---Returns a printable quest name depending on its type
---@param quest QuestData
---@return string
function Quests:getQuestName(quest)
	if (quest.name and quest.name:len() > 1) then
		return quest.name
	end
	if (quest.type == 1) then
		return TB_MENU_LOCALIZED.QUESTSNAMETYPE1
	elseif (quest.type == 2) then
		return TB_MENU_LOCALIZED.QUESTSNAMETYPE2
	elseif (quest.type == 3) then
		return TB_MENU_LOCALIZED.QUESTSNAMETYPE3
	elseif (quest.type == 4) then
		if (quest.decap) then
			return TB_MENU_LOCALIZED.QUESTSNAMETYPEDECAP
		else
			return TB_MENU_LOCALIZED.QUESTSNAMETYPE4
		end
	elseif (quest.type == 7) then
		return TB_MENU_LOCALIZED.QUESTNAMETYPEMARKET
	end
	return TB_MENU_LOCALIZED.QUESTSDEFAULTQUESTNAME
end

---Returns a printable quest objective depending on its type and requirements
---@param quest QuestData
---@return string
function Quests:getQuestObjective(quest)
	local targetText = ""
	local requirementFormatted = PlayerInfo:currencyFormat(quest.requirement)
	if (quest.type == 1) then
		targetText = (quest.dq == QUESTS_DQ and TB_MENU_LOCALIZED.QUESTSDQREQGAME or TB_MENU_LOCALIZED.QUESTSPLAYREQ) .. " " .. requirementFormatted .. " " .. (quest.ranked and TB_MENU_LOCALIZED.WORDRANKED .. " " or "") .. TB_MENU_LOCALIZED.WORDGAMES
	elseif (quest.type == 2) then
		targetText = (quest.dq == QUESTS_DQ and TB_MENU_LOCALIZED.QUESTSDQREQ or TB_MENU_LOCALIZED.QUESTSWINREQ) .. " " .. requirementFormatted .. " " .. (quest.ranked and TB_MENU_LOCALIZED.WORDRANKED .. " " or "") .. TB_MENU_LOCALIZED.WORDFIGHTS
		if (quest.dq == QUESTS_POINTS) then
			targetText = targetText .. " " .. TB_MENU_LOCALIZED.QUESTSPOINTSREQ
		end
		if (quest.decap) then
			targetText = targetText .. " " .. TB_MENU_LOCALIZED.QUESTSBYDECAP .. (quest.ranked and " " .. TB_MENU_LOCALIZED.QUESTSRANKEDMODE or "")
		end
	elseif (quest.type == 3) then
		targetText = TB_MENU_LOCALIZED.QUESTSGETREQ .. " " .. requirementFormatted .. " " .. TB_MENU_LOCALIZED.QUESTSGETREQ2 .. (quest.ranked and " " .. TB_MENU_LOCALIZED.QUESTSRANKEDMODE or "")
	elseif (quest.type == 4) then
		if (quest.decap) then
			targetText = TB_MENU_LOCALIZED.QUESTSDECAPREQ .. " " .. requirementFormatted .. " " .. TB_MENU_LOCALIZED.WORDTIMES .. (quest.ranked and " " .. TB_MENU_LOCALIZED.QUESTSRANKEDMODE or "")
		else
			targetText = TB_MENU_LOCALIZED.QUESTSDISMEMBERREQ .. " " .. requirementFormatted .. " " .. TB_MENU_LOCALIZED.WORDTIMES .. (quest.ranked and " " .. TB_MENU_LOCALIZED.QUESTSRANKEDMODE or "")
		end
	elseif (quest.type == 5) then
		targetText = TB_MENU_LOCALIZED.QUESTSBOUNTYCLAIMREQ1 .. " " .. requirementFormatted .. " " ..  TB_MENU_LOCALIZED.QUESTSBOUNTYCLAIMREQ2
	elseif (quest.type == 6) then
		targetText = TB_MENU_LOCALIZED.QUESTSBOUNTYGET1 .. " " .. requirementFormatted .. " " .. TB_MENU_LOCALIZED.QUESTSBOUNTYGET2
	elseif (quest.type == 7) then
		targetText = TB_MENU_LOCALIZED.QUESTSMARKETSPEND1 .. " " .. requirementFormatted .. " " .. TB_MENU_LOCALIZED.WORDTORICREDITS .. " " .. TB_MENU_LOCALIZED.QUESTSMARKETSPEND2
	elseif (quest.type == 8) then
		targetText = TB_MENU_LOCALIZED.QUESTSWINREQ .. " " .. requirementFormatted .. " " .. (quest.ranked and TB_MENU_LOCALIZED.WORDRANKED .. " " or "") .. TB_MENU_LOCALIZED.WORDFIGHTS .. " " .. TB_MENU_LOCALIZED.QUESTSBOUNTYPLAY
	end

	if (quest.modid ~= 0) then
		targetText = targetText .. " " .. TB_MENU_LOCALIZED.WORDIN .. " " .. quest.modname
	end
	if (quest.matchmake) then
		targetText = targetText .. " " .. TB_MENU_LOCALIZED.QUESTSMATCHMAKEREQ
	elseif (quest.official) then
		targetText = targetText .. " " .. TB_MENU_LOCALIZED.QUESTSOFFICIALREQ
	end
	return targetText
end

---Returns a printable quest reward name
---@param quest QuestData
---@return string
function Quests:getReward(quest)
	if (quest.rewardid == 0) then
		return quest.reward .. " " .. TB_MENU_LOCALIZED.WORDTC
	end
	local item = Torishop:getItemInfo(quest.rewardid)
	return item.shortname or "???"
end

---Displays quest reward in a specified UIElement viewport
---@param quest QuestData
---@param viewElement UIElement
---@return nil
function Quests:drawRewardText(quest, viewElement)
	local rewardText = Quests:getReward(quest)
	if (rewardText) then
		local iconSize = viewElement.size.h > 32 and 32 or viewElement.size.h
		local questRewardText = viewElement:addChild({
			pos = { iconSize + 20, 0 },
			size = { viewElement.size.w - iconSize - 20, viewElement.size.h }
		})
		questRewardText:addAdaptedText(true, rewardText)
		local textWidth = 0
		for i,v in pairs(questRewardText.dispstr) do
			local w = questRewardText.textScale * get_string_length(v, FONTS.MEDIUM)
			if (w > textWidth) then
				textWidth = w
			end
		end

		local questRewardIcon = viewElement:addChild({
			pos = { (viewElement.size.w - textWidth - iconSize - 10) / 2, (viewElement.size.h - iconSize) / 2 },
			size = { iconSize, iconSize },
			bgImage = quest.rewardid ~= nil and (quest.rewardid == 0 and "../textures/store/toricredit_tiny.tga" or "../textures/store/items/" .. quest.rewardid .. ".tga") or nil
		})
	end
end

function Quests:claim(quest, successFunc, errorFunc)
	Request:queue(function() claim_quest(quest.id) end, "questclaim" .. quest.id, function()
		local response = get_network_response()
		if (response:find("^GATEWAY 0; 0")) then
			update_tc_balance()
			Quests:download()
			if (quest.rewardid and quest.rewardid > 0 and quest.rewardid ~= ITEM_SHIAI_TOKEN) then
				download_inventory()
			end
			if (quest.bp_xp) then
				BattlePass:getUserData()
			end
			if (successFunc) then
				successFunc()
			end
		else
			local errorMessage = response:gsub("GATEWAY 0;.*", "")
			TBMenu:showStatusMessage(TB_MENU_LOCALIZED.REWARDSCLAIMERROROTHER .. ": " .. errorMessage, TB_MENU_MAIN_ISOPEN == 0)

			if (errorFunc) then
				errorFunc()
			end
		end
	end, function()
		TBMenu:showStatusMessage(TB_MENU_LOCALIZED.ERRORTRYAGAIN, TB_MENU_MAIN_ISOPEN == 0)
		if (errorFunc) then
			errorFunc()
		end
	end)
end

---Displays quest information in a UIElement viewport
---@param questView UIElement
---@param quest QuestData
---@param bottomSmudge UIElement Bottom smudge UIElement generated by TBMenu:addBottomBloodSmudge()
---@param customClaimFunc? function Custom function that will be executed after successful quest claiming
---@return nil
function Quests:showQuest(questView, quest, bottomSmudge, customClaimFunc)
	local bgScale = questView.size.w - 20 > questView.size.h / 5 * 3 - 20 and questView.size.h / 5 * 3 - 20 or questView.size.w - 20
	local questBackground = UIElement:new({
		parent = questView,
		pos = { (questView.size.w - bgScale) / 2, 10 },
		size = { bgScale, bgScale },
		bgColor = TB_MENU_DEFAULT_DARKEST_COLOR,
		shapeType = ROUNDED,
		rounded = bgScale
	})
	local qType = (quest.type == 4 and quest.decap) and "decap" or quest.type
	local questIcon = UIElement:new({
		parent = questBackground,
		pos = { bgScale / 5, bgScale / 5 },
		size = { bgScale / 5 * 3, bgScale / 5 * 3 },
		bgImage = "../textures/menu/general/quests/qtype" .. qType .. ".tga"
	})
	local progress = quest.progress / quest.requirement
	progress = progress > 1 and 1 or progress
	questBackground:addCustomDisplay(false, function()
			set_color(unpack(TB_MENU_DEFAULT_LIGHTER_COLOR))
			draw_disk(questBackground.pos.x + questBackground.size.w / 2, questBackground.pos.y + questBackground.size.h / 2, questBackground.size.h / 2 - 25, questBackground.size.h / 2 - 5, 100, 1, -60, -240, 0)
			set_color(unpack(UICOLORWHITE))
			draw_disk(questBackground.pos.x + questBackground.size.w / 2, questBackground.pos.y + questBackground.size.h / 2, questBackground.size.h / 2 - 25, questBackground.size.h / 2 - 5, 100, 1, -60, -240 * progress, 0)
		end)
	if (quest.timeleft < 0) then
		local progressText = UIElement:new({
			parent = questBackground,
			pos = { questBackground.size.w / 5, -questBackground.size.h / 5 },
			size = { questBackground.size.w / 5 * 3, questBackground.size.h / 8 }
		})
		progressText:addAdaptedText(true, quest.progress .. " / " .. quest.requirement)
	else
		quest.timetick = quest.timetick or os.time()
		local progressText = UIElement:new({
			parent = questBackground,
			pos = { questBackground.size.w / 5, -questBackground.size.h / 3 },
			size = { questBackground.size.w / 5 * 3, questBackground.size.h / 8 },
			bgColor = table.clone(TB_MENU_DEFAULT_DARKEST_COLOR)
		})
		progressText.bgColor[4] = 0.7
		progressText:addAdaptedText(false, quest.progress .. " / " .. quest.requirement)
		local timeleftText = UIElement:new({
			parent = questBackground,
			pos = { questBackground.size.w / 5, -questBackground.size.h / 5 },
			size = { questBackground.size.w / 5 * 3, questBackground.size.h / 7 }
		})
		timeleftText:addAdaptedText(true, TBMenu:getTime(quest.timeleft - (os.time() - quest.timetick), 2) .. " " .. TB_MENU_LOCALIZED.TIMELEFT)
		timeleftText:addCustomDisplay(true, function()
				timeleftText:uiText(TBMenu:getTime(quest.timeleft - (os.time() - quest.timetick), 2) .. " " .. TB_MENU_LOCALIZED.TIMELEFT, nil, nil, nil, nil, timeleftText.textScale)
			end)
	end
	local questName = UIElement:new({
		parent = questView,
		pos = { 10, questView.size.h / 5 * 3 },
		size = { questView.size.w - 20, questView.size.h / 10 }
	})
	questName:addAdaptedText(true, Quests:getQuestName(quest), nil, nil, FONTS.BIG, nil, 0.7)
	local questTarget = UIElement:new({
		parent = questView,
		pos = { 10, questView.size.h / 10 * 7 },
		size = { questView.size.w - 20, questView.size.h / 5 }
	})
	questTarget:addAdaptedText(true, Quests:getQuestObjective(quest))
	if (TB_STORE_DATA.ready) then
		local questReward = UIElement:new({
			parent = questView,
			pos = { 5, questView.size.h / 10 * 9 },
			size = { questView.size.w - 10, questView.size.h / 10 }
		})
		Quests:drawRewardText(quest, questReward)
	end
	if (quest.progress >= quest.requirement) then
		local questClaimBg = UIElement:new({
			parent = questView,
			pos = { 0, 0 },
			size = { questView.size.w, questView.size.h },
			bgColor = { 0, 0, 0, 0.2 }
		})
		local questClaim = UIElement:new({
			parent = questClaimBg,
			pos = { 10, (questClaimBg.size.h + 32) / 3 },
			size = { questClaimBg.size.w - 20, (questClaimBg.size.h + 32) / 3 },
			shapeType = ROUNDED,
			rounded = 5,
			innerShadow = { 0, 5 },
			shadowColor = TB_MENU_DEFAULT_ORANGE,
			bgColor = TB_MENU_DEFAULT_YELLOW,
			interactive = true,
			pressedColor = { 0.902, 0.738, 0.269, 1 },
			hoverColor = { 0.969, 0.781, 0.199, 1 }
		})
		questClaim:addMouseHandlers(nil, function()
				questView:kill(true)
				TBMenu:addBottomBloodSmudge(questView, 1)
				TBMenu:displayLoadingMark(questView, "Claiming Quest")
				Quests:claim(quest, function()
					if (customClaimFunc) then
						customClaimFunc()
					else
						Quests:showMain()
					end
				end)
			end)
		local claimText = UIElement:new({
			parent = questClaim,
			pos = { 10, 0 },
			size = { questClaim.size.w - 20, questClaim.size.h / 2 }
		})
		claimText:addAdaptedText(false, TB_MENU_LOCALIZED.QUESTSCLAIMREWARD, nil, nil, FONTS.BIG, nil, 0.7, nil, nil, 1.8)
		local buttonSize = questClaim.size.h - 15 > 40 and 40 or questClaim.size.h - 15
		local claimButton = UIElement:new({
			parent = questClaim,
			pos = { 10, -5 - (questClaim.size.h / 2 + buttonSize) / 2 },
			size = { questClaim.size.w - 20, buttonSize },
			shapeType = ROUNDED,
			rounded = 5,
			bgColor = { 0.594, 0.418, 0.14, 1 }
		})
		if (TB_STORE_DATA.ready) then
			Quests:drawRewardText(quest, claimButton)
		end
		bottomSmudge:reload()
	end
end

function Quests:requiresGlobalDataUpdate()
	return (not Quests.QuestsGlobalData or QUESTS_LASTUPDATE.time + 300 < os.time() or QUESTS_LASTUPDATE.qi ~= TB_MENU_PLAYER_INFO.data.qi) or QUESTS_LASTUPDATE.requireUpdate
end

function Quests:downloadGlobal()
	-- If QuestsGlobalData is present, make sure we don't queue data updates too frequently
	if (not Quests:requiresGlobalDataUpdate()) then
		Quests:getGlobalQuests()
		return false
	end

	download_global_quests()
	return true
end

---Parses global quest information from the quests_global data file
---@param fileData? File File object created by Files:open(). If nil, default path for global quests will be used.
---@return nil
function Quests:getGlobalQuests(fileData)
	TB_MENU_QUESTS_GLOBAL_COUNT = 0
	local fileData = fileData or Files:open("../data/quests_global.dat")

	if (not fileData.data and not fileData:isDownloading()) then
		QUESTS_LASTUPDATE.time = 0
		Quests:downloadGlobal()
		Quests.QuestDataErrors = Quests.QuestDataErrors + 1
		return
	end

	---@type QuestData[]
	local globalQuests = {}
	local dataTypes = {
		{ 'id', numeric = true },
		{ 'type', numeric = true },
		{ 'name' },
		{ 'requirement', numeric = true },
		{ 'progress', numeric = true },
		{ 'modid', numeric = true },
		{ 'claimed', boolean = true },
		{ 'available', boolean = true },
		{ 'rewardid', numeric = true },
		{ 'reward', numeric = true },
		{ 'description' }
	}
	for i, ln in pairs(fileData:readAll()) do
		if (not string.match(ln, "^questid")) then
			local _, segments = ln:gsub("\t", "")
			local data_stream = { ln:match(("([^\t]*)\t?"):rep(segments)) }

			---@type QuestData
			local quest = {}
			for i,v in pairs(dataTypes) do
				quest[v[1]] = data_stream[i]
				if (v.numeric) then
					quest[v[1]] = tonumber(quest[v[1]]) or 0
				elseif (v.boolean) then
					quest[v[1]] = quest[v[1]] == '1'
				end
			end
			quest.global = true
			quest.description = quest.description ~= '' and quest.description or false
			quest.progresspercentage = math.min(1, quest.progress / quest.requirement)
			table.insert(globalQuests, quest)

			if (quest.progresspercentage >= 1 and not quest.claimed) then
				TB_MENU_QUESTS_GLOBAL_COUNT = TB_MENU_QUESTS_GLOBAL_COUNT + 1
			end
		end
	end

	fileData:close()

	Quests.QuestsGlobalData = table.qsort(globalQuests, { "type", "progresspercentage" }, { SORT_ASCENDING, SORT_DESCENDING })
	QUESTS_LASTUPDATE.time = os.time()
	QUESTS_LASTUPDATE.qi = TB_MENU_PLAYER_INFO.data.qi
end

---Returns navigation data for legacy Global Quests screen
---@deprecated
---@return MenuNavButton[]
function Quests:getGlobalQuestsNavigation()
	return {
		{
			text = TB_MENU_LOCALIZED.NAVBUTTONBACK,
			action = function() TBMenu:clearNavSection() Notifications:showMain(true) end
		},
		{
			text = TB_MENU_LOCALIZED.QUESTSGLOBALCOMPLETED,
			action = function() Quests:showGlobalQuests(Quests.QuestsGlobalData, true) end,
			right = true,
			sectionId = 2
		},
		{
			text = TB_MENU_LOCALIZED.QUESTSGLOBALACTIVE,
			action = function() Quests:showGlobalQuests(Quests.QuestsGlobalData) end,
			right = true,
			sectionId = 1
		},
	}
end

---Prepares global quests display screen and shows them when ready
---@deprecated
---@return nil
function Quests:prepareGlobalQuests()
	TB_MENU_SPECIAL_SCREEN_ISOPEN = 0
	TBMenu.CurrentSection:kill(true)
	TBMenu:clearNavSection()
	TBMenu:showNavigationBar(Quests:getGlobalQuestsNavigation(), true, true, 1)

	if (QUESTS_LASTUPDATE.time + 60 >= os.time() or QUESTS_LASTUPDATE.qi == TB_MENU_PLAYER_INFO.data.qi) then
		-- Not enough time has passed or they haven't played any games so progress should be same
		Quests:showGlobalQuests(Quests.QuestsGlobalData)
		return
	end

	download_global_quests()
	local loader = UIElement:new({
		parent = TBMenu.CurrentSection,
		pos = { 5, 0 },
		size = { TBMenu.CurrentSection.size.w - 10, TBMenu.CurrentSection.size.h },
		bgColor = TB_MENU_DEFAULT_BG_COLOR
	})
	TBMenu:addBottomBloodSmudge(loader, 1)
	TBMenu:displayLoadingMark(loader, TB_MENU_LOCALIZED.QUESTSGLOBALUPDATING)

	local questsFile = Files:open("../data/quests_global.dat")
	loader:addCustomDisplay(false, function()
			if (questsFile:isDownloading()) then
				return
			end

			questsFile:reopen()
			Quests:getGlobalQuests(questsFile)
			Quests:showGlobalQuests(Quests.QuestsGlobalData)
		end)
end

---Displays a horizontal quest button
---@param quest QuestData
---@param listingHolder UIElement Listing holder generated by TBMenu:prepareScrollableList()
---@param listElements UIElement[] List of elements added to `listingHolder`
---@param elementHeight number
---@return nil
function Quests:showQuestButton(quest, listingHolder, listElements, elementHeight)
	local questHolder = listingHolder:addChild({
		pos = { 0, #listElements * elementHeight },
		size = { listingHolder.size.w, elementHeight }
	})
	table.insert(listElements, questHolder)
	local questBackground = questHolder:addChild({
		pos = { 10, 3 },
		size = { questHolder.size.w - 12, questHolder.size.h - 3 },
		bgColor = TB_MENU_DEFAULT_DARKER_COLOR,
		shapeType = ROUNDED,
		rounded = { 4, 0 }
	})
	if (not quest.description and (quest.timeleft and quest.timeleft < 0)) then
		questBackground.size.h = questBackground.size.h - 3
		questBackground:setRounded(4)
	end
	local questTitle = questBackground:addChild({
		pos = { 10, 5 },
		size = { questBackground.size.w / 4, questBackground.size.h - 10 }
	})
	questTitle:addAdaptedText(true, quest.name, nil, nil, nil, LEFTMID)

	local questProgressOutline = questBackground:addChild({
		pos = { questTitle.shift.x + questTitle.size.w + 10, 10 },
		size = { questBackground.size.w / 2 - 20, questBackground.size.h - 20 },
		bgColor = TB_MENU_DEFAULT_DARKEST_COLOR,
		shapeType = ROUNDED,
		rounded = 10
	})
	local questProgressBar = questProgressOutline:addChild({
		shift = { 2, 2 },
		bgColor = TB_MENU_DEFAULT_DARKER_COLOR,
		shapeType = questProgressOutline.shapeType,
		rounded = questProgressOutline.rounded / 5 * 4
	})
	local questProgressBarState
	if (quest.progress > 0) then
		questProgressBarState = questProgressBar:addChild({
			pos = { 0, 0 },
			size = { questProgressBar.size.w * quest.progresspercentage, questProgressBar.size.h },
			shapeType = questProgressBar.shapeType,
			rounded = questProgressBar.rounded,
			interactive = quest.progresspercentage >= 1 and not quest.claimed,
			bgColor = (quest.progresspercentage < 1 or quest.claimed) and TB_MENU_DEFAULT_BG_COLOR or TB_MENU_DEFAULT_ORANGE,
			hoverColor = TB_MENU_DEFAULT_DARKER_ORANGE,
			pressedColor = TB_MENU_DEFAULT_YELLOW,
			innerShadow = { 3, 3 },
			shadowColor = { (quest.progresspercentage < 1 or quest.claimed) and TB_MENU_DEFAULT_LIGHTER_COLOR or TB_MENU_DEFAULT_YELLOW, (quest.progresspercentage < 1 or quest.claimed) and TB_MENU_DEFAULT_DARKEST_COLOR or TB_MENU_DEFAULT_DARKER_ORANGE }
		})
	end
	local questProgressText = questProgressBar:addChild({
		shift = { questProgressBar.size.w / 3, 3 }
	})
	if (quest.progresspercentage < 1) then
		questProgressText:addAdaptedText(true, quest.progress .. " / " .. quest.requirement, nil, nil, nil, nil, nil, nil, nil, 1)
	elseif (quest.claimed) then
		questProgressText:addAdaptedText(true, TB_MENU_LOCALIZED.REWARDSCLAIMSUCCESS, nil, nil, nil, nil, nil, nil, nil, 1)
	else
		questProgressText:addAdaptedText(true, TB_MENU_LOCALIZED.QUESTSCLAIMREWARD, nil, nil, nil, nil, nil, nil, nil, 1)
		questProgressBarState:addMouseHandlers(nil, function()
				questProgressBarState:deactivate(true)
				questProgressText:addCustomDisplay(true, function() end)
				TBMenu:displayLoadingMarkSmall(questProgressBarState, "", questProgressText.textFont)
				Request:queue(function()
					if (quest.global) then
						claim_quest_global(quest.id)
					else
						claim_quest(quest.id)
					end
				end, "net_questclaim", function()
						if (not quest.global) then
							update_tc_balance()
							Quests:download(true)
							add_hook("downloader_complete", "net_questclaim_post", function(filename)
									if (filename:find("data/quest.txt")) then
										remove_hooks("net_questclaim_post")
										Downloader:safeCall(function()
											if (questProgressBarState and not questProgressBarState.destroyed) then
												Quests:showMain()
											end
										end)
									end
								end)
							if (quest.bp_xp > 0) then
								BattlePass:getUserData()
							end
							if (quest.rewardid > 0 and quest.rewardid ~= ITEM_SHIAI_TOKEN) then
								download_inventory()
							end
							return
						end
						questProgressBarState:kill(true)
						local response = get_network_response()
						if (response:find("GATEWAY 0; 0")) then
							update_tc_balance()
							download_inventory()

							TB_MENU_QUESTS_GLOBAL_COUNT = math.max(0, TB_MENU_QUESTS_GLOBAL_COUNT - 1)
							quest.claimed = true
							questProgressBarState.bgColor = TB_MENU_DEFAULT_DARKER_COLOR
							questProgressBarState.inactiveColor = TB_MENU_DEFAULT_DARKER_COLOR
							questProgressBarState.shadowColor = { TB_MENU_DEFAULT_LIGHTER_COLOR, TB_MENU_DEFAULT_DARKEST_COLOR }
							questProgressText:addAdaptedText(true, TB_MENU_LOCALIZED.REWARDSCLAIMSUCCESS, nil, nil, nil, nil, nil, nil, nil, 1)
						else
							TBMenu:showStatusMessage(TB_MENU_LOCALIZED.ERRORTRYAGAIN)
							questProgressBarState:activate()
							questProgressText:addAdaptedText(true, TB_MENU_LOCALIZED.QUESTSCLAIMREWARD, nil, nil, nil, nil, nil, nil, nil, 1)
						end
					end, function()
						questProgressBarState:kill(true)
						TBMenu:showStatusMessage(TB_MENU_LOCALIZED.ERRORTRYAGAIN)
						questProgressBarState:activate()
						questProgressText:addAdaptedText(true, TB_MENU_LOCALIZED.QUESTSCLAIMREWARD, nil, nil, nil, nil, nil, nil, nil, 1)
					end)
			end)
	end

	local rewardText = quest.reward > 0 and (quest.rewardid == 0 and (quest.reward .. " " .. TB_MENU_LOCALIZED.WORDTORICREDITS) or (quest.rewardid == ITEM_SHIAI_TOKEN and (quest.reward .. " " .. TB_MENU_LOCALIZED.WORDSHIAITOKENS) or Torishop:getItemInfo(quest.rewardid).itemname)) or ''
	if (quest.bp_xp and quest.bp_xp > 0) then
		rewardText = rewardText .. (rewardText:len() > 0 and "\n" or "") .. quest.bp_xp .. " " .. TB_MENU_LOCALIZED.BATTLEPASSEXPERIENCE
	end
	if (rewardText ~= "") then
		local rewardIcon = quest.rewardid > 0 and (quest.rewardid == ITEM_SHIAI_TOKEN and "../textures/store/shiaitoken.tga" or Torishop:getItemIcon(quest.rewardid)) or (quest.reward > 0 and "../textures/store/toricredit.tga" or nil)
		local shiftX = 0
		if (rewardIcon ~= nil) then
			local questRewardIcon = questBackground:addChild({
				pos = { -questBackground.size.h, 5 },
				size = { questBackground.size.h - 10, questBackground.size.h - 10 },
				bgImage = rewardIcon
			})
			shiftX = shiftX + questRewardIcon.size.w
		end
		if (quest.bp_xp and quest.bp_xp > 0) then
			local questBPIcon = questBackground:addChild({
				pos = { -questBackground.size.h - shiftX, 5 },
				size = { questBackground.size.h - 10, questBackground.size.h - 10 },
				bgImage = "../textures/menu/battlepass/experience.tga"
			})
			shiftX = shiftX + questBPIcon.size.w
		end
		if (not quest.description and (quest.timeleft and quest.timeleft <= 0)) then
			questBackground:addChild({
				pos = { questProgressOutline.shift.x + questProgressOutline.size.w + 10, questTitle.shift.y },
				size = { questBackground.size.w - questProgressOutline.size.w - questProgressOutline.shift.x - 30 - shiftX, questTitle.size.h }
			}):addAdaptedText(true, TB_MENU_LOCALIZED.WORDREWARD ..  ":\n" .. rewardText, nil, nil, 4, RIGHTMID, 0.7)
		end
	end

	if (quest.description or (quest.timeleft and quest.timeleft > 0)) then
		local questDescHolder = listingHolder:addChild({
			pos = { 0, #listElements * elementHeight },
			size = { listingHolder.size.w, elementHeight }
		})
		table.insert(listElements, questDescHolder)
		local questDescBackground = questDescHolder:addChild({
			pos = { 10, 0 },
			size = { questDescHolder.size.w - 12, questDescHolder.size.h - 3 },
			bgColor = TB_MENU_DEFAULT_DARKER_COLOR,
			shapeType = ROUNDED,
			rounded = { 0, 4 }
		})
		local shiftY = 0
		if (quest.description) then
			local questDescText = questDescBackground:addChild({
				pos = { 10, 0 },
				size = { questProgressOutline.shift.x + questProgressOutline.size.w - 20, questDescBackground.size.h - 5 }
			})
			if (quest.timeleft and quest.timeleft > 0) then
				questDescText.size.h = questDescText.size.h * 0.65
				shiftY = questDescText.size.h
			end
			questDescText:addAdaptedText(true, quest.description, nil, nil, 4, (quest.timeleft and quest.timeleft > 0) and LEFT or LEFTMID, 0.7)
		end
		if (quest.timeleft and quest.timeleft > 0) then
			local questTimeleftText = questDescBackground:addChild({
				pos = { 10, shiftY },
				size = { questProgressOutline.shift.x + questProgressOutline.size.w - 20, questDescBackground.size.h - shiftY - 5 },
				uiColor = { 1, 1, 1, 0.75 }
			})
			questTimeleftText:addCustomDisplay(true, function()
				local timeleft = quest.timeleft - (os.time() - QUESTS_LASTUPDATE.time)
				if (timeleft > 0) then
					questTimeleftText:uiText(TB_MENU_LOCALIZED.QUESTEXPIRESIN .. " " .. TBMenu:getTime(timeleft, 2), nil, nil, 4, LEFTMID, 0.6)
				else
					questProgressBar.bgColor = table.clone(TB_MENU_DEFAULT_INACTIVE_COLOR_TRANS)
					if (questProgressBarState) then
						questProgressBarState:deactivate()
						questProgressBarState.bgColor = table.clone(TB_MENU_DEFAULT_INACTIVE_COLOR_TRANS)
						questProgressBarState.innerShadow[1] = 0
						questProgressBarState.innerShadow[2] = 0
					end
					questTimeleftText:addAdaptedText(true, TB_MENU_LOCALIZED.QUESTEXPIREDMSG, nil, nil, 4, LEFTMID, 0.6)
					QUESTS_LASTUPDATE.requireUpdate = true
				end
			end)
		end

		if (rewardText ~= "") then
			questDescBackground:addChild({
				pos = { questProgressOutline.shift.x + questProgressOutline.size.w + 30, questTitle.shift.y },
				size = { questBackground.size.w - questProgressOutline.size.w - questProgressOutline.shift.x - 40, questTitle.size.h }
			}):addAdaptedText(true, TB_MENU_LOCALIZED.WORDREWARD ..  ":\n" .. rewardText, nil, nil, 4, RIGHT, 0.7)
		end
	end
end

---@deprecated
---Use Quests:showQuestButton() instead
---@param quest QuestData
---@param listingHolder UIElement
---@param listElements UIElement[]
---@param elementHeight number
---@return nil
function Quests:showGlobalQuestButton(quest, listingHolder, listElements, elementHeight)
	Quests:showQuestButton(quest, listingHolder, listElements, elementHeight)
end

---@deprecated
---@param questsData QuestData[]
---@param completed? boolean Whether we're showing completed quests or those still in progress
---@return nil
function Quests:showGlobalQuests(questsData, completed)
	usage_event("questsglobal")
	TBMenu.CurrentSection:kill(true)
	local completed = completed or false

	local elementHeight = 60
	local mainHolder = UIElement:new({
		parent = TBMenu.CurrentSection,
		pos = { 5, 0 },
		size = { TBMenu.CurrentSection.size.w - 10, TBMenu.CurrentSection.size.h },
		bgColor = TB_MENU_DEFAULT_BG_COLOR
	})
	local toReload, topBar, botBar, listingView, listingHolder, listingScrollBG = TBMenu:prepareScrollableList(mainHolder, elementHeight, elementHeight - 16, 20, TB_MENU_DEFAULT_BG_COLOR)

	local questsHeader = UIElement:new({
		parent = topBar,
		pos = { 15, 13 },
		size = { topBar.size.w - 30, topBar.size.h - 26 }
	})
	questsHeader:addAdaptedText(true, TB_MENU_LOCALIZED.QUESTSGLOBAL, nil, nil, FONTS.BIG, LEFTMID)
	TBMenu:addBottomBloodSmudge(botBar)

	local listElements = {}
	local shownQuests = { count = 0 }
	local shownSections = {}

	if (not completed) then
		local availableQuests = 0
		local closestAndAvailableQuests = UIElement:new({
			parent = listingHolder,
			pos = { 20, #listElements * elementHeight },
			size = { listingHolder.size.w - 40, elementHeight }
		})
		closestAndAvailableQuests:addAdaptedText(false, TB_MENU_LOCALIZED.QUESTSCLOSEST, nil, nil, nil, LEFTMID)
		table.insert(listElements, closestAndAvailableQuests)
		for i, quest in pairs(UIElement:qsort(questsData, { "progresspercentage", "requirement" })) do
			if (quest.available and not quest.claimed) then
				availableQuests = availableQuests + 1
				if (not shownSections[quest.type]) then
					Quests:showGlobalQuestButton(quest, listingHolder, listElements, elementHeight)
					shownQuests[quest.id] = true
					if (quest.modreq == 0) then
						shownSections[quest.type] = true
					else
						shownSections[quest.type] = {}
						shownSections[quest.type][quest.modreq] = true
					end
					shownQuests.count = shownQuests.count + 1
				elseif (quest.progress > quest.requirement) then
					Quests:showGlobalQuestButton(quest, listingHolder, listElements, elementHeight)
					shownQuests[quest.id] = true
					shownQuests.count = shownQuests.count + 1
				elseif (type(shownSections[quest.type]) == "table") then
					if (not shownSections[quest.type][quest.modreq]) then
						Quests:showGlobalQuestButton(quest, listingHolder, listElements, elementHeight)
						shownQuests[quest.id] = true
						shownSections[quest.type][quest.modreq] = true
						shownQuests.count = shownQuests.count + 1
					end
				end
			end
		end
		if (shownQuests.count == 0) then
			closestAndAvailableQuests:kill()
			table.remove(listElements)
		end
		if (shownQuests.count < availableQuests) then
			local lockedQuestsSeparator = UIElement:new({
				parent = listingHolder,
				pos = { 0, #listElements * elementHeight },
				size = { listingHolder.size.w, elementHeight }
			})
			lockedQuestsSeparator:addCustomDisplay(true, function() end)
			table.insert(listElements, lockedQuestsSeparator)
			local lockedQuests = UIElement:new({
				parent = listingHolder,
				pos = { 20, #listElements * elementHeight },
				size = { listingHolder.size.w - 40, elementHeight }
			})
			lockedQuests:addAdaptedText(false, TB_MENU_LOCALIZED.QUESTSLOCKED, nil, nil, nil, LEFTMID)
			table.insert(listElements, lockedQuests)
		end
	end

	for i, quest in pairs(questsData) do
		if (completed == quest.claimed and not shownQuests[quest.id] and (quest.claimed or quest.available)) then
			Quests:showGlobalQuestButton(quest, listingHolder, listElements, elementHeight)
		end
	end

	if (#listElements == 0) then
		listingHolder:addAdaptedText(true, TB_MENU_LOCALIZED.NOTHINGTOSHOW)
		return
	end

	for i,v in pairs(listElements) do
		v:hide()
	end
	local scrollBar = TBMenu:spawnScrollBar(listingHolder, #listElements, elementHeight)
	scrollBar:makeScrollBar(listingHolder, listElements, toReload)
end

---Displays the legacy Quests screen
---@return nil
--[[function Quests:showQuestsLegacy()
	TBMenu.CurrentSection:kill(true)
	local TBMenu.CurrentSection = TBMenu.CurrentSection:addChild({ shift = { 0, 0 }})
	local globalQuests = UIElement:new({
		parent = TBMenu.CurrentSection,
		pos = { 5, 0 },
		size = { TBMenu.CurrentSection.size.w / 7 * 2 - 10, TBMenu.CurrentSection.size.h },
		bgColor = TB_MENU_DEFAULT_BG_COLOR,
		interactive = true,
		hoverColor = TB_MENU_DEFAULT_DARKER_COLOR,
		pressedColor = TB_MENU_DEFAULT_DARKEST_COLOR,
		hoverSound = 31
	})

	local questsToClaimIcon = nil
	if (TB_MENU_QUESTS_GLOBAL_COUNT > 0) then
		questsToClaimIcon = UIElement:new({
			parent = globalQuests,
			pos = { globalQuests.size.w / 6, globalQuests.size.h / 7 * 2 },
			size = { globalQuests.size.w / 5, globalQuests.size.w / 5 },
			shapeType = ROUNDED,
			rounded = globalQuests.size.w / 5,
			bgColor = TB_MENU_DEFAULT_BG_COLOR
		})
		questsToClaimIcon:addCustomDisplay(false, function()
				questsToClaimIcon:uiText("!", nil, nil, FONTS.BIG)
			end)
	end
	TBMenu:showHomeButton(globalQuests, {
			title = TB_MENU_LOCALIZED.QUESTSGLOBAL,
			subtitle = TB_MENU_LOCALIZED.QUESTSGLOBALDESC,
			ratio = 1,
			image = "../textures/menu/modmaker.tga",
			mode = ORIENTATION_PORTRAIT,
			action = function()
					Quests:prepareGlobalQuests()
				end
		}, 1, questsToClaimIcon)
	if (questsToClaimIcon) then
		questsToClaimIcon:hide()
		questsToClaimIcon:show()
	end

	local questsHolderWidth = math.max(TBMenu.CurrentSection.size.w - globalQuests.size.w - globalQuests.shift.x - 5, #Quests.QuestsData * WIN_H / 3)
	local questsHolder = UIElement:new({
		parent = TBMenu.CurrentSection,
		pos = { globalQuests.size.w + globalQuests.shift.x + 5, 0 },
		size = { questsHolderWidth, TBMenu.CurrentSection.size.h }
	})
	if (Quests.QuestsData) then
		for i, quest in pairs(Quests.QuestsData) do
			local questView = UIElement:new({
				parent = questsHolder,
				pos = { 5 + (i - 1) * questsHolder.size.w / #Quests.QuestsData, 0 },
				size = { questsHolder.size.w / #Quests.QuestsData - 10, questsHolder.size.h },
				bgColor = TB_MENU_DEFAULT_BG_COLOR
			})
			local bottomSmudge = TBMenu:addBottomBloodSmudge(questView, i)
			Quests:showQuest(questView, quest, bottomSmudge)
		end
		if (TBMenu.CurrentSection.size.w - globalQuests.size.w - globalQuests.shift.x - 5 < questsHolderWidth) then
			local scrollRight = TBMenu:createImageButtons(TBMenu.CurrentSection.parent, TBMenu.CurrentSection.shift.x + TBMenu.CurrentSection.size.w - 32, TBMenu.CurrentSection.shift.y + TBMenu.CurrentSection.size.h / 2 - 32, 32, 64, "../textures/menu/general/buttons/arrowright.tga", nil, nil, { 0, 0, 0, 0.4 }, { 0, 0, 0, 0.7 }, { 0, 0, 0, 0.6 }, 8)
			local scrollLeft = TBMenu:createImageButtons(TBMenu.CurrentSection.parent, 0, TBMenu.CurrentSection.shift.y + TBMenu.CurrentSection.size.h / 2 - 32, 32, 64, "../textures/menu/general/buttons/arrowleft.tga", nil, nil, { 0, 0, 0, 0.4 }, { 0, 0, 0, 0.7 }, { 0, 0, 0, 0.6 }, 8)

			scrollRight:addMouseHandlers(nil, function()
					local animator = TBMenu.CurrentSection:addChild({ shift = { 0, 0 } })
					local targetPoint = _G.TBMenu.CurrentSection.pos.x + TBMenu.CurrentSection.size.w
					animator:addCustomDisplay(true, function()
						scrollRight:hide()
						if (questsHolder.pos.x - 50 + questsHolder.size.w < targetPoint) then
							TBMenu.CurrentSection:moveTo(-questsHolder.shift.x - questsHolder.size.w)
							animator:kill()
							scrollLeft:show()
						else
							TBMenu.CurrentSection:moveTo(-50, nil, true)
						end
					end)
				end, nil)
			scrollLeft:addMouseHandlers(nil, function()
					local animator = TBMenu.CurrentSection:addChild({ shift = { 0, 0 } })
					local targetPoint = _G.TBMenu.CurrentSection.pos.x
					animator:addCustomDisplay(true, function()
						scrollLeft:hide()
						if (TBMenu.CurrentSection.pos.x + 50 > targetPoint) then
							TBMenu.CurrentSection:moveTo(0)
							animator:kill()
							scrollRight:show()
						else
							TBMenu.CurrentSection:moveTo(50, nil, true)
						end
					end)
				end, nil)
		scrollLeft:hide()
		end
	else
		local questView = UIElement:new({
			parent = questsHolder,
			pos = { 5, 0 },
			size = { questsHolder.size.w - 10, questsHolder.size.h },
			bgColor = TB_MENU_DEFAULT_BG_COLOR
		})
		TBMenu:addBottomBloodSmudge(questView, i)
		questView:addAdaptedText(false, TB_MENU_LOCALIZED.NOTHINGTOSHOW)
	end
end]]

---Displays Quests screen home. If quests data is missing, queues download and shows loading screen first.
---@deprecated
---@param reload? boolean
---@return nil
--[[function Quests:showMainLegacy(reload)
	usage_event("quests")
	TBMenu.CurrentSection:kill(true)
	if (Quests.QuestsData and not reload) then
		Quests:showQuestsLegacy()
	else
		if (reload) then
			Quests:download()
		end
		local waitView = UIElement:new({
			parent = TBMenu.CurrentSection,
			pos = { 5, 0 },
			size = { TBMenu.CurrentSection.size.w - 10, TBMenu.CurrentSection.size.h },
			bgColor = TB_MENU_DEFAULT_BG_COLOR
		})
		TBMenu:addBottomBloodSmudge(waitView, 1)
		waitView:addCustomDisplay(false, function()
				waitView:uiText(TB_MENU_LOCALIZED.QUESTSUPDATING)
				if (Quests.QuestsData) then
					if (waitView and not waitView.destroyed) then
						Quests:showQuestsLegacy()
					end
				end
			end)
	end
end]]

---Displays the list of player's quests
---@param viewElement UIElement
---@param questsData table
---@return nil
function Quests:showMainQuestList(viewElement, questsData)
	viewElement:kill(true)

	local elementHeight = 60
	local toReload, topBar, botBar, listingView, listingHolder, scrollBackground = TBMenu:prepareScrollableList(viewElement, 70, elementHeight, 20, TB_MENU_DEFAULT_BG_COLOR)

	topBar:addChild({ shift = { 20, 5 }}):addAdaptedText(questsData.name, nil, nil, FONTS.BIG, nil, 0.7)
	TBMenu:addBottomBloodSmudge(botBar, 2)

	local listElements = {}
	for i,v in pairs(questsData.quests) do
		Quests:showQuestButton(v, listingHolder, listElements, elementHeight)
	end
	if (#listElements * elementHeight > listingHolder.size.h) then
		for i,v in pairs(listElements) do
			v:hide()
		end

		local scrollBar = TBMenu:spawnScrollBar(listingHolder, #listElements, elementHeight)
		listingHolder.scrollBar = scrollBar
		scrollBar:makeScrollBar(listingHolder, listElements, toReload)
	else
		listingHolder:moveTo((listingHolder.parent.size.w - listingHolder.size.w) / 4, nil, true)
	end
end

---Internal function to display quest type buttons for Quests main screen
---@param listingHolder UIElement
---@param v table
---@param listElements UIElement[]
---@param elementHeight number
---@param listView UIElement Viewport for quests display that will get reloaded on button click
---@param sectionIdx? integer Section id to store last active quests tab
---@return nil
function Quests:displayMainQuestTypeButton(listingHolder, v, listElements, elementHeight, listView, sectionIdx)
	if (#v.quests > 0) then
		local listButton = listingHolder:addChild({
			pos = { 0, #listElements * elementHeight },
			size = { listingHolder.size.w, elementHeight }
		})
		table.insert(listElements, listButton)
		local buttonHolder = listButton:addChild({
			pos = { 10, 2 },
			size = { listButton.size.w - 12, listButton.size.h - 4 },
			shapeType = ROUNDED,
			rounded = 4,
			bgColor = v.selected and TB_MENU_DEFAULT_DARKEST_COLOR or TB_MENU_DEFAULT_DARKER_COLOR,
			hoverColor = TB_MENU_DEFAULT_DARKEST_COLOR,
			pressedColor = TB_MENU_DEFAULT_LIGHTER_COLOR,
			interactive = true
		})
		local buttonText = buttonHolder:addChild({
			pos = { 10, 3 },
			size = { buttonHolder.size.w * 0.8 - 15, buttonHolder.size.h - 6 }
		})
		buttonText:addAdaptedText(v.name, nil, nil, 4, LEFTMID, 0.8)
		local buttonQuestsCount = buttonHolder:addChild({
			pos = { -buttonHolder.size.h, 5 },
			size = { buttonHolder.size.h - 10, buttonHolder.size.h - 10 },
			bgColor = TB_MENU_DEFAULT_INACTIVE_COLOR_TRANS,
			shapeType = ROUNDED,
			rounded = buttonHolder.size.h
		})
		buttonQuestsCount:addChild({ shift = { 3, 3 }}):addAdaptedText(#v.quests .. "", nil, nil, 4, nil, 0.7)
		if (v.canBeClaimed > 0) then
			local markSize = 14
			buttonQuestsCount:addChild({
				pos = { -markSize * 0.9, -buttonQuestsCount.size.h - markSize * 0.1 },
				size = { markSize, markSize },
				bgColor = TB_MENU_DEFAULT_ORANGE,
				shapeType = ROUNDED,
				rounded = markSize / 2
			})
		end
		buttonHolder:addMouseUpHandler(function()
				if (listingHolder.selectedButton and listingHolder.selectedButton ~= buttonHolder) then
					listingHolder.selectedButton.bgColor = table.clone(TB_MENU_DEFAULT_DARKER_COLOR)
					listingHolder.selectedButton = buttonHolder
					listingHolder.selectedButton.bgColor = table.clone(TB_MENU_DEFAULT_DARKEST_COLOR)
					Quests:showMainQuestList(listView, v)
					TB_MENU_QUESTS_ACTIVE_SECTION = sectionIdx
				end
			end)

		if (v.selected) then
			listingHolder.selectedButton = buttonHolder
		end
	end
end

---Displays a scrollable list with available quest types
---@param viewElement UIElement
---@param listView UIElement
function Quests:showMainQuestTypes(viewElement, listView)
	local REGULAR = 1
	local LIMITED = 2
	local RANKED = 3
	local BATTLEPASS = 4

	local regularQuestList = {
		{
			name = TB_MENU_LOCALIZED.QUESTSREPEATING,
			quests = {},
			canBeClaimed = 0
		},
		{
			name = TB_MENU_LOCALIZED.QUESTSLIMITED,
			quests = {},
			canBeClaimed = 0
		},
		{
			name = TB_MENU_LOCALIZED.QUESTSRANKED,
			quests = {},
			canBeClaimed = 0
		},
		{
			name = TB_MENU_LOCALIZED.QUESTSBATTLEPASS,
			quests = {},
			canBeClaimed = 0
		}
	}

	local function putQuestInSection(quest, section)
		table.insert(regularQuestList[section].quests, quest)
		if (quest.progress >= quest.requirement) then
			regularQuestList[section].canBeClaimed = regularQuestList[section].canBeClaimed + 1
		end
	end

	for i,v in pairs(Quests.QuestsData) do
		if (v.ranked) then
			putQuestInSection(v, RANKED)
		elseif (v.bp_xp > 0) then
			putQuestInSection(v, BATTLEPASS)
		elseif (v.timeleft > 0) then
			putQuestInSection(v, LIMITED)
		else
			putQuestInSection(v, REGULAR)
		end
	end

	local GLOBALACTIVE = 1
	local GLOBALCOMPLETED = 2
	local globalQuestList = {
		{
			name = TB_MENU_LOCALIZED.QUESTSGLOBALACTIVE,
			quests = {},
			canBeClaimed = 0
		},
		{
			name = TB_MENU_LOCALIZED.QUESTSGLOBALCOMPLETED,
			quests = {},
			canBeClaimed = 0
		}
	}
	for i,v in pairs(Quests.QuestsGlobalData) do
		if (v.claimed) then
			table.insert(globalQuestList[GLOBALCOMPLETED].quests, v)
		else
			table.insert(globalQuestList[GLOBALACTIVE].quests, v)
			if (v.progress >= v.requirement) then
				globalQuestList[GLOBALACTIVE].canBeClaimed = globalQuestList[GLOBALACTIVE].canBeClaimed + 1
			end
		end
	end

	local elementHeight = 50
	local toReload, topBar, botBar, listingView, listingHolder, scrollBackground = TBMenu:prepareScrollableList(viewElement, 70, elementHeight, 20, TB_MENU_DEFAULT_BG_COLOR)
	local listElements = {}

	topBar:addChild({ shift = { 10, 5 } }):addAdaptedText(TB_MENU_LOCALIZED.NAVBUTTONQUESTS, nil, nil, FONTS.BIG, nil, 0.7)
	TBMenu:addBottomBloodSmudge(botBar, 1)

	local regularQuestsTitle = listingHolder:addChild({
		pos = { 0, 0 },
		size = { listingHolder.size.w, elementHeight }
	})
	table.insert(listElements, regularQuestsTitle)
	regularQuestsTitle:addChild({ shift = { 15, 5 }}):addAdaptedText(TB_MENU_LOCALIZED.QUESTSREGULAR, nil, nil, FONTS.BIG, LEFTMID)

	if (regularQuestList[TB_MENU_QUESTS_ACTIVE_SECTION] == nil or #regularQuestList[TB_MENU_QUESTS_ACTIVE_SECTION].quests < 1) then
		TB_MENU_QUESTS_ACTIVE_SECTION = 1
	end
	regularQuestList[TB_MENU_QUESTS_ACTIVE_SECTION].selected = true
	for i,v in pairs(regularQuestList) do
		Quests:displayMainQuestTypeButton(listingHolder, v, listElements, elementHeight, listView, i)
	end

	table.insert(listElements, listingHolder:addChild({
		pos = { 0, #listElements * elementHeight },
		size = { listingHolder.size.w, elementHeight }
	}))

	local globalQuestsTitle = listingHolder:addChild({
		pos = { 0, #listElements * elementHeight },
		size = { listingHolder.size.w, elementHeight }
	})
	table.insert(listElements, globalQuestsTitle)
	globalQuestsTitle:addChild({ shift = { 15, 5 }}):addAdaptedText(TB_MENU_LOCALIZED.QUESTSGLOBAL, nil, nil, FONTS.BIG, LEFTMID)

	for i,v in pairs(globalQuestList) do
		Quests:displayMainQuestTypeButton(listingHolder, v, listElements, elementHeight, listView)
	end

	if (#listElements * elementHeight > listingHolder.size.h) then
		for i,v in pairs(listElements) do
			v:hide()
		end

		local scrollBar = TBMenu:spawnScrollBar(listingHolder, #listElements, elementHeight)
		listingHolder.scrollBar = scrollBar
		scrollBar:makeScrollBar(listingHolder, listElements, toReload)
	else
		listingHolder:moveTo((listingHolder.parent.size.w - listingHolder.size.w) / 4, nil, true)
	end

	Quests:showMainQuestList(listView, regularQuestList[TB_MENU_QUESTS_ACTIVE_SECTION])
end

---Displays the main Quests screen
---@param navBack? boolean
---@param backFunc? function
---@return nil
function Quests:showQuests(navBack, backFunc)
	TBMenu:clearNavSection()
	TBMenu:showNavigationBar(Notifications:getNavigationButtons(navBack, nil, backFunc), true, true, 2)

	local questTypesView = TBMenu.CurrentSection:addChild({
		pos = { 5, 0 },
		size = { TBMenu.CurrentSection.size.w / 4 - 10, TBMenu.CurrentSection.size.h },
		bgColor = TB_MENU_DEFAULT_BG_COLOR
	})
	local questListView = TBMenu.CurrentSection:addChild({
		pos = { questTypesView.shift.x + questTypesView.size.w + 10, 0 },
		size = { TBMenu.CurrentSection.size.w - questTypesView.shift.x - questTypesView.size.w - 15, TBMenu.CurrentSection.size.h },
		bgColor = TB_MENU_DEFAULT_BG_COLOR
	})
	Quests:showMainQuestTypes(questTypesView, questListView)
end

---Prepares the main Quests screen for display.\
---If quests data is empty, fetches and parses the data file first.
---@param navBack? boolean
---@param backFunc? function
---@return nil
function Quests:showMain(navBack, backFunc)
	usage_event("quests")
	TBMenu.CurrentSection:kill(true)

	if (Quests.QuestsData and not Quests:requiresGlobalDataUpdate()) then
		Quests:showQuests(navBack, backFunc)
		return
	end
	TBMenu:clearNavSection()
	TBMenu:showNavigationBar(Notifications:getNavigationButtons(navBack, nil, backFunc), true, true, 2)

	Quests:download()
	local updatingView = TBMenu.CurrentSection:addChild({
		shift = { 5, 0 },
		bgColor = TB_MENU_DEFAULT_BG_COLOR
	})
	TBMenu:displayLoadingMark(updatingView, TB_MENU_LOCALIZED.QUESTSUPDATING)
	TBMenu:addBottomBloodSmudge(updatingView, 1)
	local spawnClock = os.clock()
	updatingView:addCustomDisplay(function()
			if (Quests.QuestsData and Quests.QuestsGlobalData) then
				Quests:showQuests(navBack, backFunc)
			end
			if (os.clock() - spawnClock > 10 and Quests.QuestDataErrors > 0) then
				updatingView:kill(true)
				updatingView:addAdaptedText(TB_MENU_LOCALIZED.ERRORTRYAGAIN)
				TBMenu:addBottomBloodSmudge(updatingView, 1)
			end
		end)
end
