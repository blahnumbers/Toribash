require("system.menu_backend_defines")
require("toriui.uielement")
require("system.iofiles")
require("system.battlepass_manager")

---@alias QuestDQMode
---| 0 # QUESTS_DQ_ANY | Default
---| 1 # QUESTS_DQ | Win by point score
---| 2 # QUESTS_POINTS | Win by disqualification

---@class QuestData
---@field id integer
---@field global boolean
---@field type integer
---@field progress integer Current quest progress
---@field requirement integer Required quest progress for it to be completed
---@field timeleft integer Time left until quest expiry
---@field modid integer ID of the mod required for quest progression
---@field modname string Name of the mod required for quest progression
---@field decap boolean If true, quest requires the player to decap an opponent during the fight
---@field matchmake boolean If true, quest requires the fight to be played in matchmaking mode
---@field official boolean If true, quest requires the fight to be played in an official (static) room. *Regular quests only*.
---@field dq QuestDQMode Whether this quest requires the fight to end in a specific way
---@field reward integer Reward amount
---@field rewardid integer Item ID of the reward. If zero, `reward` value indicates TC reward.
---@field bp_xp integer Battle Pass XP awarded for completing the quest
---@field name string Custom or autogenerated quest name
---@field ranked boolean If true, quest requires the fight to be played in ranked mode. *Regular quests only*.
---@field claimed boolean Whether the quest has been completed by the user. *Global quests only*.
---@field available boolean Whether the quest is currently available for the user. *Global quests only*.
---@field progresspercentage number Quest progress percentage
---@field description string Additional information about the quest

if (Quests == nil) then
	---**Toribash quests manager class**
	---
	---**Version 5.70**
	---* Added `HookName` field
	---
	---**Version 5.65**
	---* Removed previously deprecated functions
	--
	-- **Version 5.62:**
	-- * Display generic reward elements from Battle Pass class
	-- * Legacy methods explicitly marked deprecated and to be removed in future
	--
	-- **Version 5.60 updates:**
	-- * Added EmmyLua annotations
	--
	-- **Ver 1.3 updates:**
	-- * Updated visuals to show all quests same as global quests from previous versions
	-- * Quests:showGlobalQuestButton() is now Quests:showQuestButton()
	-- * Battle Pass quests support
	--
	-- **Ver 1.2 updates:**
	-- * Allow scrolling the quests list if there are too many of them to not shrink the buttons by too much
	---@class Quests
	---@field QuestsData QuestData[] Table containing all active regular quests for current user
	---@field QuestsGlobalData QuestData[] Table containing information on all global quests for the user
	---@field QuestDataErrors integer Will be non-zero if quest data file parsing resulted in an error
	---@field PopupDisplayDuration number
	Quests = {
		ver = 5.70,
		QuestDataErrors = 0,
		PopupDisplayDuration = 2.5,
		HookName = "__tbQuestsManager"
	}
end

---Downloads quests data file and stores last update time to QUESTS_LASTUPDATE.time\
---Will not queue the file for download if it's already in download queue or has been downloaded within past 5 seconds.
---@param override? boolean If true, will force the update even if update clock says it's too early to do so
---@return boolean #Whether file download has been initiated
function Quests:download(override)
	local clock = os.time()
	if (not override and clock - (QUESTS_LASTUPDATE.time or 0) < 5) then
		return false
	end

	local downloads = get_downloads()
	local downloadingQuest, downloadingGlobalQuest
	for _, v in pairs(downloads) do
		if (v:find("quest.txt$")) then
			downloadingQuest = true
		elseif (v:find("quests_global.txt$")) then
			downloadingGlobalQuest = true
		end
	end

	if (downloadingQuest and downloadingGlobalQuest) then
		return false
	end

	QUESTS_LASTUPDATE.time = clock
	if (not downloadingQuest) then
		Quests.QuestsData = nil
		download_quest(TB_MENU_PLAYER_INFO.username)
	end
	if (not downloadingGlobalQuest) then
		Quests:downloadGlobal()
	end
	return true
end

---Parses information about available quests from the data file.\
---If data file is missing, increments Quests.QuestDataErrors and queues it for download.
function Quests:getQuests()
	TB_MENU_QUESTS_COUNT = 0
	local file = Files.Open("../data/quest.txt")
	if (not file.data) then
		Quests:download()
		Quests.QuestDataErrors = Quests.QuestDataErrors + 1
	end
	local fileData = file:readAll()
	file:close()

	Quests.QuestsData = {}
	local dataTypes = {
		{ "id", numeric = true },
		{ "type", numeric = true },
		{ "progress", numeric = true },
		{ "requirement", numeric = true },
		{ "timeleft", numeric = true },
		{ "modid", numeric = true },
		{ "modname" },
		{ "decap", boolean = true },
		{ "matchmake", boolean = true },
		{ "official", boolean = true },
		{ "reward", numeric = true },
		{ "rewardid", numeric = true },
		{ "name" },
		{ "ranked", boolean = true },
		{ "dq", numeric = true },
		{ "bp_xp", numeric = true },
		{ "description" }
	}

	for _, ln in pairs(fileData) do
		if (not ln:find("^#")) then
			local _, segments = ln:gsub("([^\t]*)\t?", "")
			local dataStream = { ln:match(("([^\t]*)\t?"):rep(segments)) }

			---@type QuestData
			local quest = { claimed = false }
			for i,v in pairs(dataTypes) do
				quest[v[1]] = dataStream[i]
				if (v.numeric) then
					---@diagnostic disable-next-line: assign-type-mismatch
					quest[v[1]] = tonumber(quest[v[1]]) or 0
				elseif (v.boolean) then
					quest[v[1]] = quest[v[1]] == '1'
				end
			end
			quest.name = (quest.name and quest.name:len() > 0) and quest.name or Quests:getQuestName(quest)
			quest.description = (quest.description and quest.description:len() > 0) and quest.description or Quests:getQuestObjective(quest)
			quest.progresspercentage = math.min(1, quest.progress / quest.requirement)
			table.insert(Quests.QuestsData, quest)

			if (quest.progress >= quest.requirement) then
				-- Handle special quest types
				-- These are claimed automatically upon reaching the objective, so mark them as claimed
				if (quest.type >= 1000) then
					quest.claimed = true
					quest.requirement = quest.progress + 1
				else
					TB_MENU_QUESTS_COUNT = TB_MENU_QUESTS_COUNT + 1
				end
			end
		end
	end

	if (BattlePass.UserData) then
		Quests:addBattlePassQuests()
	end

	---@type QuestData[]
	Quests.QuestsData = table.qsort(Quests.QuestsData, { "timeleft", "progresspercentage", "claimed" }, { SORT_ASCENDING, SORT_DESCENDING, SORT_ASCENDING })
end

---Adds hardcoded Battle Pass quests that automark themselves on completion
function Quests:addBattlePassQuests()
	for _, v in pairs(Quests.QuestsData) do
		if (v.id == 2000) then
			return
		end
	end

	local loginRewardsAvailable = PlayerInfo.getLoginRewards().available
	table.insert(Quests.QuestsData, {
		id = 2000,
		name = TB_MENU_LOCALIZED.QUESTSDAILYPLAYER,
		description = "Log in and claim login rewards",
		progresspercentage = loginRewardsAvailable and 0 or 1,
		requirement = loginRewardsAvailable and 1 or 2,
		progress = loginRewardsAvailable and 0 or 1,
		claimed = not loginRewardsAvailable,
		type = 0,
		timeleft = PlayerInfo.getLoginRewards().timeLeft,
		modid = 0,
		modname = '',
		reward = 0,
		rewardid = 0,
		bp_xp = 10
	})
end

---Updates daily login quest status
---@param completed boolean
---@return boolean
function Quests:updateLoginQuestStatus(completed)
	if (not Quests.QuestsData) then
		return false
	end

	for i,v in pairs(Quests.QuestsData) do
		if (v.id == 2000) then
			Quests.QuestsData[i].requirement = completed and 2 or 1
			Quests.QuestsData[i].progress = completed and 1 or 0
			Quests.QuestsData[i].progresspercentage = completed and 1 or 0
			Quests.QuestsData[i].claimed = completed
			Quests.QuestsData = table.qsort(Quests.QuestsData, { "timeleft", "progresspercentage", "claimed" }, { SORT_ASCENDING, SORT_DESCENDING, SORT_ASCENDING })
			return true
		end
	end
	return false
end

---Returns quest data with the matching quest id. If no quest is found, returns `false`.
---@param id integer
---@return QuestData?
function Quests:getQuestById(id)
	if (not Quests.QuestsData) then
		Quests:getQuests()
	end
	if (Quests.QuestsData) then
		for i,v in pairs(Quests.QuestsData) do
			if (v.id == id) then
				return Quests.QuestsData[i]
			end
		end
	end
	return nil
end

---@param quest QuestData
---@param progress integer
function Quests:setQuestProgress(quest, progress)
	quest.progress = quest.requirement < progress and quest.requirement or progress
	quest.progresspercentage = quest.progress / quest.requirement
end

---Returns a printable quest name depending on its type
---@param quest QuestData
---@return string
function Quests:getQuestName(quest)
	if (quest.name and quest.name:len() > 1) then
		return quest.name
	end
	if (quest.type == 1) then
		return TB_MENU_LOCALIZED.QUESTSNAMETYPE1
	elseif (quest.type == 2) then
		return TB_MENU_LOCALIZED.QUESTSNAMETYPE2
	elseif (quest.type == 3) then
		return TB_MENU_LOCALIZED.QUESTSNAMETYPE3
	elseif (quest.type == 4) then
		if (quest.decap) then
			return TB_MENU_LOCALIZED.QUESTSNAMETYPEDECAP
		else
			return TB_MENU_LOCALIZED.QUESTSNAMETYPE4
		end
	elseif (quest.type == 7) then
		return TB_MENU_LOCALIZED.QUESTNAMETYPEMARKET
	end
	return TB_MENU_LOCALIZED.QUESTSDEFAULTQUESTNAME
end

---Returns a printable quest objective depending on its type and requirements
---@param quest QuestData
---@return string
function Quests:getQuestObjective(quest)
	local targetText = ""
	local requirementFormatted = numberFormat(quest.requirement)
	if (quest.type == 1) then
		targetText = (quest.dq == QUESTS_DQ and TB_MENU_LOCALIZED.QUESTSDQREQGAME or TB_MENU_LOCALIZED.QUESTSPLAYREQ) .. " " .. requirementFormatted .. " " .. (quest.ranked and TB_MENU_LOCALIZED.WORDRANKED .. " " or "") .. TB_MENU_LOCALIZED.WORDGAMES
	elseif (quest.type == 2) then
		targetText = (quest.dq == QUESTS_DQ and TB_MENU_LOCALIZED.QUESTSDQREQ or TB_MENU_LOCALIZED.QUESTSWINREQ) .. " " .. requirementFormatted .. " " .. (quest.ranked and TB_MENU_LOCALIZED.WORDRANKED .. " " or "") .. TB_MENU_LOCALIZED.WORDFIGHTS
		if (quest.dq == QUESTS_POINTS) then
			targetText = targetText .. " " .. TB_MENU_LOCALIZED.QUESTSPOINTSREQ
		end
		if (quest.decap) then
			targetText = targetText .. " " .. TB_MENU_LOCALIZED.QUESTSBYDECAP .. (quest.ranked and " " .. TB_MENU_LOCALIZED.QUESTSRANKEDMODE or "")
		end
	elseif (quest.type == 3) then
		targetText = TB_MENU_LOCALIZED.QUESTSGETREQ .. " " .. requirementFormatted .. " " .. TB_MENU_LOCALIZED.QUESTSGETREQ2 .. (quest.ranked and " " .. TB_MENU_LOCALIZED.QUESTSRANKEDMODE or "")
	elseif (quest.type == 4) then
		if (quest.decap) then
			targetText = TB_MENU_LOCALIZED.QUESTSDECAPREQ .. " " .. requirementFormatted .. " " .. TB_MENU_LOCALIZED.WORDTIMES .. (quest.ranked and " " .. TB_MENU_LOCALIZED.QUESTSRANKEDMODE or "")
		else
			targetText = TB_MENU_LOCALIZED.QUESTSDISMEMBERREQ .. " " .. requirementFormatted .. " " .. TB_MENU_LOCALIZED.WORDTIMES .. (quest.ranked and " " .. TB_MENU_LOCALIZED.QUESTSRANKEDMODE or "")
		end
	elseif (quest.type == 5) then
		targetText = TB_MENU_LOCALIZED.QUESTSBOUNTYCLAIMREQ1 .. " " .. requirementFormatted .. " " ..  TB_MENU_LOCALIZED.QUESTSBOUNTYCLAIMREQ2
	elseif (quest.type == 6) then
		targetText = TB_MENU_LOCALIZED.QUESTSBOUNTYGET1 .. " " .. requirementFormatted .. " " .. TB_MENU_LOCALIZED.QUESTSBOUNTYGET2
	elseif (quest.type == 7) then
		targetText = TB_MENU_LOCALIZED.QUESTSMARKETSPEND1 .. " " .. requirementFormatted .. " " .. TB_MENU_LOCALIZED.WORDTORICREDITS .. " " .. TB_MENU_LOCALIZED.QUESTSMARKETSPEND2
	elseif (quest.type == 8) then
		targetText = TB_MENU_LOCALIZED.QUESTSWINREQ .. " " .. requirementFormatted .. " " .. (quest.ranked and TB_MENU_LOCALIZED.WORDRANKED .. " " or "") .. TB_MENU_LOCALIZED.WORDFIGHTS .. " " .. TB_MENU_LOCALIZED.QUESTSBOUNTYPLAY
	end

	if (quest.modid ~= 0) then
		targetText = targetText .. " " .. TB_MENU_LOCALIZED.WORDIN .. " " .. quest.modname
	end
	if (quest.matchmake) then
		targetText = targetText .. " " .. TB_MENU_LOCALIZED.QUESTSMATCHMAKEREQ
	elseif (quest.official) then
		targetText = targetText .. " " .. TB_MENU_LOCALIZED.QUESTSOFFICIALREQ
	end
	return targetText
end

---Queues a network request to claim the specified quest with callbacks
---@param quest QuestData
---@param successFunc function?
---@param errorFunc function?
---@overload fun(self: Quests, quests: QuestData[], successFunc?: function, errorFunc?: function)
function Quests:claim(quest, successFunc, errorFunc)
	local quests = quest.id ~= nil and { quest } or quest
	local questIds = { }
	local isGlobal = false
	local reloadInventory = false
	local reloadBattlePass = false
	for _, v in pairs(quests) do
		if (v.global) then
			isGlobal = true
		end
		if (v.rewardid ~= nil and v.rewardid > 0 and v.rewardid ~= ITEM_SHIAI_TOKEN) then
			reloadInventory = true
		end
		if (v.bp_xp ~= nil and v.bp_xp > 0) then
			reloadBattlePass = true
		end
		table.insert(questIds, v.id)
	end
	if (isGlobal and #questIds > 1) then
		Files.LogError("Error running Quests.claim(): multi claim with global quests is not supported")
		return
	end

	Request:queue(function()
		if (isGlobal) then
			claim_quest_global(unpack(questIds))
		else
			claim_quest(unpack(questIds))
		end
	end, "questclaim" .. quests[1].id, function()
		local response = get_network_response()
		if (response:find("^GATEWAY 0; 0")) then
			update_tc_balance()
			Quests:download(true)
			if (reloadInventory) then
				download_inventory()
			end
			if (reloadBattlePass) then
				BattlePass:getUserData()
			end
			if (successFunc) then
				successFunc()
			end
		else
			local errorMessage = response:gsub("GATEWAY 0;.*", "")
			TBMenu:showStatusMessage(TB_MENU_LOCALIZED.REWARDSCLAIMERROROTHER .. ": " .. errorMessage)

			if (errorFunc) then
				errorFunc()
			end
		end
	end, function()
		TBMenu:showStatusMessage(TB_MENU_LOCALIZED.ERRORTRYAGAIN)
		if (errorFunc) then
			errorFunc()
		end
	end)
end

function Quests:requiresGlobalDataUpdate()
	return (not Quests.QuestsGlobalData or QUESTS_LASTUPDATE.time + 300 < os.time() or QUESTS_LASTUPDATE.qi ~= TB_MENU_PLAYER_INFO.data.qi) or QUESTS_LASTUPDATE.requireUpdate
end

function Quests:downloadGlobal()
	-- If QuestsGlobalData is present, make sure we don't queue data updates too frequently
	if (not Quests:requiresGlobalDataUpdate()) then
		Quests:getGlobalQuests()
		return false
	end

	download_global_quests()
	return true
end

---Parses global quest information from the quests_global data file
---@param fileData? File File object created by Files.Open(). If nil, default path for global quests will be used.
function Quests:getGlobalQuests(fileData)
	TB_MENU_QUESTS_GLOBAL_COUNT = 0
	local fileData = fileData or Files.Open("../data/quests_global.dat")

	if (not fileData.data and not fileData:isDownloading()) then
		QUESTS_LASTUPDATE.time = 0
		Quests:downloadGlobal()
		Quests.QuestDataErrors = Quests.QuestDataErrors + 1
		return
	end

	---@type QuestData[]
	local globalQuests = {}
	local dataTypes = {
		{ 'id', numeric = true },
		{ 'type', numeric = true },
		{ 'name' },
		{ 'requirement', numeric = true },
		{ 'progress', numeric = true },
		{ 'modid', numeric = true },
		{ 'claimed', boolean = true },
		{ 'available', boolean = true },
		{ 'rewardid', numeric = true },
		{ 'reward', numeric = true },
		{ 'description' }
	}
	for i, ln in pairs(fileData:readAll()) do
		if (not string.match(ln, "^questid")) then
			local _, segments = ln:gsub("\t", "")
			local data_stream = { ln:match(("([^\t]*)\t?"):rep(segments)) }

			---@type QuestData
			local quest = {}
			for i,v in pairs(dataTypes) do
				quest[v[1]] = data_stream[i]
				if (v.numeric) then
					quest[v[1]] = tonumber(quest[v[1]]) or 0
				elseif (v.boolean) then
					quest[v[1]] = quest[v[1]] == '1'
				end
			end
			quest.global = true
			---@diagnostic disable-next-line: assign-type-mismatch
			quest.description = quest.description ~= '' and quest.description or nil
			quest.progresspercentage = math.min(1, quest.progress / quest.requirement)
			table.insert(globalQuests, quest)

			if (quest.progresspercentage >= 1 and not quest.claimed) then
				TB_MENU_QUESTS_GLOBAL_COUNT = TB_MENU_QUESTS_GLOBAL_COUNT + 1
			end
		end
	end

	fileData:close()

	Quests.QuestsGlobalData = table.qsort(globalQuests, { "type", "progresspercentage" }, { SORT_ASCENDING, SORT_DESCENDING })
	QUESTS_LASTUPDATE.time = os.time()
	QUESTS_LASTUPDATE.qi = TB_MENU_PLAYER_INFO.data.qi
end


---Displays a horizontal quest button
---@param quest QuestData
---@param listingHolder UIElement Listing holder generated by TBMenu:prepareScrollableList()
---@param listElements UIElement[] List of elements added to `listingHolder`
---@param elementHeight number
function Quests:showQuestButton(quest, listingHolder, listElements, elementHeight)
	local questHolder = listingHolder:addChild({
		pos = { 0, #listElements * elementHeight },
		size = { listingHolder.size.w, elementHeight }
	})
	table.insert(listElements, questHolder)
	local questBackground = questHolder:addChild({
		pos = { 10, 3 },
		size = { questHolder.size.w - 12, questHolder.size.h - 3 },
		bgColor = TB_MENU_DEFAULT_DARKER_COLOR,
		shapeType = ROUNDED,
		rounded = { 4, 0 }
	})
	if (not quest.description and (not quest.timeleft or quest.timeleft < 0)) then
		questBackground.size.h = questBackground.size.h - 3
		questBackground:setRounded(4)
	end
	local questTitle = questBackground:addChild({
		pos = { 10, 5 },
		size = { questBackground.size.w / 4, questBackground.size.h - 10 }
	})
	questTitle:addAdaptedText(true, quest.name, nil, nil, nil, LEFTMID)

	local questProgressOutline = questBackground:addChild({
		pos = { questTitle.shift.x + questTitle.size.w + 10, 10 },
		size = { questBackground.size.w / 2 - 20, questBackground.size.h - 20 },
		bgColor = TB_MENU_DEFAULT_DARKEST_COLOR,
		shapeType = ROUNDED,
		rounded = 10
	})
	local questProgressBar = questProgressOutline:addChild({
		shift = { 2, 2 },
		bgColor = TB_MENU_DEFAULT_DARKER_COLOR,
		shapeType = questProgressOutline.shapeType,
		rounded = questProgressOutline.rounded / 5 * 4
	})
	local questProgressBarState
	if (quest.progress > 0) then
		questProgressBarState = questProgressBar:addChild({
			pos = { 0, 0 },
			size = { questProgressBar.size.w * quest.progresspercentage, questProgressBar.size.h },
			shapeType = questProgressBar.shapeType,
			rounded = questProgressBar.rounded,
			interactive = quest.progresspercentage >= 1 and not quest.claimed,
			bgColor = (quest.progresspercentage < 1 or quest.claimed) and TB_MENU_DEFAULT_BG_COLOR or TB_MENU_DEFAULT_ORANGE,
			hoverColor = TB_MENU_DEFAULT_DARKER_ORANGE,
			pressedColor = TB_MENU_DEFAULT_YELLOW,
			innerShadow = { 3, 3 },
			shadowColor = { (quest.progresspercentage < 1 or quest.claimed) and TB_MENU_DEFAULT_LIGHTER_COLOR or TB_MENU_DEFAULT_YELLOW, (quest.progresspercentage < 1 or quest.claimed) and TB_MENU_DEFAULT_DARKEST_COLOR or TB_MENU_DEFAULT_DARKER_ORANGE }
		})
	end
	local questProgressText = questProgressBar:addChild({
		shift = { questProgressBar.size.w / 3, 3 }
	})
	if (quest.progresspercentage < 1) then
		questProgressText:addAdaptedText(true, quest.progress .. " / " .. quest.requirement, nil, nil, nil, nil, nil, nil, nil, 1)
	elseif (quest.claimed) then
		questProgressText:addAdaptedText(true, TB_MENU_LOCALIZED.REWARDSCLAIMSUCCESS, nil, nil, nil, nil, nil, nil, nil, 1)
	else
		questProgressText:addAdaptedText(true, TB_MENU_LOCALIZED.QUESTSCLAIMREWARD, nil, nil, nil, nil, nil, nil, nil, 1)
		questProgressBarState:addMouseHandlers(nil, function()
				questProgressBarState:deactivate(true)
				questProgressText:addCustomDisplay(true, function() end)
				TBMenu:displayLoadingMarkSmall(questProgressBarState, "", questProgressText.textFont)
				Quests:claim(quest, function()
						add_hook("downloader_complete", self.HookName, function(filename)
							if (filename:find("data/quest.txt")) then
								remove_hook("downloader_complete", self.HookName)
								Downloader.SafeCall(function()
									if (questProgressBarState and not questProgressBarState.destroyed) then
										Quests:showMain()
									end
								end)
							end
						end)

						TB_MENU_QUESTS_GLOBAL_COUNT = math.max(0, TB_MENU_QUESTS_GLOBAL_COUNT - 1)
						quest.claimed = true
						questProgressBarState.bgColor = TB_MENU_DEFAULT_DARKER_COLOR
						questProgressBarState.inactiveColor = TB_MENU_DEFAULT_DARKER_COLOR
						questProgressBarState.shadowColor = { TB_MENU_DEFAULT_LIGHTER_COLOR, TB_MENU_DEFAULT_DARKEST_COLOR }
						questProgressText:addAdaptedText(true, TB_MENU_LOCALIZED.REWARDSCLAIMSUCCESS, nil, nil, nil, nil, nil, nil, nil, 1)
					end, function()
						questProgressBarState:activate(true)
						questProgressText:addAdaptedText(true, TB_MENU_LOCALIZED.QUESTSCLAIMREWARD, nil, nil, nil, nil, nil, nil, nil, 1)
					end)
			end)
	end

	local shiftX = 0
	if (quest.reward > 0) then
		---@type BattlePassReward
		local prize = {
			---@diagnostic disable-next-line: assign-type-mismatch
			tc = quest.rewardid == 0 and quest.reward or nil,
			---@diagnostic disable-next-line: assign-type-mismatch
			st = quest.rewardid == ITEM_SHIAI_TOKEN and quest.reward or nil,
			---@diagnostic disable-next-line: assign-type-mismatch
			itemid = (quest.rewardid ~= 0 and quest.rewardid ~= ITEM_SHIAI_TOKEN) and quest.rewardid or nil,
			static = true,
			bgColor = (quest.claimed or quest.progresspercentage < 1) and TB_MENU_DEFAULT_BG_COLOR or TB_MENU_DEFAULT_ORANGE,
			bgOutlineColor = TB_MENU_DEFAULT_DARKEST_COLOR,
			claimed = quest.claimed
		}
		local rewardHolder = questBackground:addChild({
			pos = { -questBackground.size.h, 0 },
			size = { questBackground.size.h, questBackground.size.h }
		})
		BattlePass:showPrizeItem(rewardHolder, prize)
		shiftX = shiftX + rewardHolder.size.w + 5
	end
	if (quest.bp_xp and quest.bp_xp > 0) then
		---@type BattlePassReward
		local prize = {
			bpxp = quest.bp_xp,
			static = true,
			bgColor = (quest.claimed or quest.progresspercentage < 1) and TB_MENU_DEFAULT_BG_COLOR or TB_MENU_DEFAULT_ORANGE,
			bgOutlineColor = TB_MENU_DEFAULT_DARKEST_COLOR,
			claimed = quest.claimed
		}
		local rewardHolder = questBackground:addChild({
			pos = { -questBackground.size.h - shiftX, 0 },
			size = { questBackground.size.h, questBackground.size.h }
		})
		BattlePass:showPrizeItem(rewardHolder, prize)
		shiftX = shiftX + rewardHolder.size.w + 5
	end

	if (quest.description or (quest.timeleft and quest.timeleft > 0)) then
		local questDescHolder = listingHolder:addChild({
			pos = { 0, #listElements * elementHeight },
			size = { listingHolder.size.w, elementHeight }
		})
		table.insert(listElements, questDescHolder)
		local questDescBackground = questDescHolder:addChild({
			pos = { 10, 0 },
			size = { questDescHolder.size.w - 12, questDescHolder.size.h - 3 },
			bgColor = TB_MENU_DEFAULT_DARKER_COLOR,
			shapeType = ROUNDED,
			rounded = { 0, 4 }
		})
		if (quest.description) then
			local questDescText = questDescBackground:addChild({
				pos = { 10, 0 },
				size = { questDescBackground.size.w - 20, questDescBackground.size.h - 5 }
			})
			if (quest.timeleft and quest.timeleft > 0) then
				questDescText.size.h = questDescText.size.h - 13
			end
			questDescText:addAdaptedText(true, quest.description, nil, nil, 4, LEFTMID, 0.75)
		end
		if (quest.timeleft and quest.timeleft > 0) then
			local questTimeleftText = questDescBackground:addChild({
				pos = { 10, questDescBackground.size.h - 18 },
				size = { questDescBackground.size.w - 20, 13 },
				uiColor = { 1, 1, 1, 0.75 }
			})
			questTimeleftText:addCustomDisplay(true, function()
				local timeleft = quest.timeleft - (os.time() - QUESTS_LASTUPDATE.time)
				if (timeleft > 0) then
					questTimeleftText:uiText(TB_MENU_LOCALIZED.QUESTEXPIRESIN .. " " .. TBMenu:getTime(timeleft, 2), nil, nil, 4, RIGHT, 0.6)
				else
					questProgressBar.bgColor = table.clone(TB_MENU_DEFAULT_INACTIVE_COLOR_DARK)
					if (questProgressBarState) then
						questProgressBarState:deactivate()
						questProgressBarState.bgColor = table.clone(TB_MENU_DEFAULT_INACTIVE_COLOR_DARK)
						questProgressBarState.innerShadow[1] = 0
						questProgressBarState.innerShadow[2] = 0
					end
					questTimeleftText:addAdaptedText(true, TB_MENU_LOCALIZED.QUESTEXPIREDMSG, nil, nil, 4, RIGHT, 0.6)
					QUESTS_LASTUPDATE.requireUpdate = true
				end
			end)
		end
	end
end

---Displays the list of player's quests
---@param viewElement UIElement
---@param questsData QuestCategory
function Quests:showMainQuestList(viewElement, questsData)
	viewElement:kill(true)

	local elementHeight = 60
	local toReload, topBar, botBar, _, listingHolder = TBMenu:prepareScrollableList(viewElement, elementHeight, elementHeight, 20, TB_MENU_DEFAULT_BG_COLOR)

	topBar:addChild({ shift = { 20, 5 }}):addAdaptedText(questsData.name, nil, nil, FONTS.BIG, nil, 0.7)
	TBMenu:addBottomBloodSmudge(botBar, 2)

	local listElements = {}
	for _, v in pairs(questsData.quests) do
		Quests:showQuestButton(v, listingHolder, listElements, elementHeight)
	end
	if (#listElements * elementHeight > listingHolder.size.h) then
		for _, v in pairs(listElements) do
			v:hide()
		end

		local scrollBar = TBMenu:spawnScrollBar(listingHolder, #listElements, elementHeight)
		listingHolder.scrollBar = scrollBar
		scrollBar:makeScrollBar(listingHolder, listElements, toReload)
	else
		listingHolder:moveTo((listingHolder.parent.size.w - listingHolder.size.w) / 4, nil, true)
	end

	if (#questsData.canBeClaimed > 0) then
		local claimButtonWidth = math.min(topBar.size.w - 20, 700)
		local claimAllButton = botBar:addChild({
			pos = { (topBar.size.w - claimButtonWidth) / 2, 5 },
			size = { claimButtonWidth, topBar.size.h - 10 },
			interactive = true,
			bgColor = TB_MENU_DEFAULT_DARKER_COLOR,
			hoverColor = TB_MENU_DEFAULT_DARKEST_COLOR,
			pressedColor = TB_MENU_DEFAULT_LIGHTER_COLOR,
			shapeType = ROUNDED,
			rounded = 4
		})
		claimAllButton:addAdaptedText(TB_MENU_LOCALIZED.EVENTSCLAIMALL)
		claimAllButton:addMouseUpHandler(function()
			local spinner = claimAllButton:addChild({ bgColor = claimAllButton.bgColor }, true)
			TBMenu:displayLoadingMark(spinner)
			local listingHolderOverlay = toReload:addChild({
				pos = { 0, topBar.size.h },
				size = { topBar.size.w, toReload.size.h - topBar.size.h - botBar.size.h },
				bgColor = TB_MENU_DEFAULT_BG_COLOR_TRANS,
				interactive = true
			})
			Quests:claim(questsData.canBeClaimed, function()
				add_hook("downloader_complete", self.HookName, function(filename)
					if (filename:find("data/quest.txt")) then
						remove_hook("downloader_complete", self.HookName)
						Downloader.SafeCall(function()
							if (claimAllButton and not claimAllButton.destroyed) then
								Quests:showMain()
							end
						end)
					end
				end)
				for _, v in pairs(questsData.canBeClaimed) do
					v.claimed = true
					TB_MENU_QUESTS_GLOBAL_COUNT = math.max(0, TB_MENU_QUESTS_GLOBAL_COUNT - 1)
				end
				spinner:kill()
				listingHolderOverlay:kill()
			end, function()
				spinner:kill()
				listingHolderOverlay:kill()
			end)
		end)
	end
end

---Internal function to display quest type buttons for Quests main screen
---@param listingHolder UIElement
---@param v table
---@param listElements UIElement[]
---@param elementHeight number
---@param listView UIElement Viewport for quests display that will get reloaded on button click
---@param sectionIdx? integer Section id to store last active quests tab
function Quests:displayMainQuestTypeButton(listingHolder, v, listElements, elementHeight, listView, sectionIdx)
	if (#v.quests > 0) then
		local listButton = listingHolder:addChild({
			pos = { 0, #listElements * elementHeight },
			size = { listingHolder.size.w, elementHeight }
		})
		table.insert(listElements, listButton)
		local buttonHolder = listButton:addChild({
			pos = { 10, 2 },
			size = { listButton.size.w - 12, listButton.size.h - 4 },
			shapeType = ROUNDED,
			rounded = 4,
			bgColor = v.selected and TB_MENU_DEFAULT_DARKEST_COLOR or TB_MENU_DEFAULT_DARKER_COLOR,
			hoverColor = TB_MENU_DEFAULT_DARKEST_COLOR,
			pressedColor = TB_MENU_DEFAULT_LIGHTER_COLOR,
			interactive = true
		})
		local buttonText = buttonHolder:addChild({
			pos = { 10, 3 },
			size = { buttonHolder.size.w * 0.8 - 15, buttonHolder.size.h - 6 }
		})
		buttonText:addAdaptedText(v.name, nil, nil, 4, LEFTMID, 0.8)
		local buttonQuestsCount = buttonHolder:addChild({
			pos = { -buttonHolder.size.h, 5 },
			size = { buttonHolder.size.h - 10, buttonHolder.size.h - 10 },
			bgColor = TB_MENU_DEFAULT_INACTIVE_COLOR_DARK,
			shapeType = ROUNDED,
			rounded = buttonHolder.size.h
		})
		buttonQuestsCount:addChild({ shift = { 3, 3 }}):addAdaptedText(#v.quests .. "", nil, nil, 4, nil, 0.7)
		if (#v.canBeClaimed > 0) then
			local markSize = 14
			buttonQuestsCount:addChild({
				pos = { -markSize * 0.9, -buttonQuestsCount.size.h - markSize * 0.1 },
				size = { markSize, markSize },
				bgColor = TB_MENU_DEFAULT_ORANGE,
				shapeType = ROUNDED,
				rounded = markSize / 2
			})
		end
		buttonHolder:addMouseUpHandler(function()
				if (listingHolder.selectedButton and listingHolder.selectedButton ~= buttonHolder) then
					listingHolder.selectedButton.bgColor = table.clone(TB_MENU_DEFAULT_DARKER_COLOR)
					listingHolder.selectedButton = buttonHolder
					listingHolder.selectedButton.bgColor = table.clone(TB_MENU_DEFAULT_DARKEST_COLOR)
					Quests:showMainQuestList(listView, v)
					TB_MENU_QUESTS_ACTIVE_SECTION = sectionIdx
				end
			end)

		if (v.selected) then
			listingHolder.selectedButton = buttonHolder
		end
	end
end

---@class QuestCategory
---@field name string
---@field quests QuestData[]
---@field canBeClaimed QuestData[]

---Displays a scrollable list with available quest types
---@param viewElement UIElement
---@param listView UIElement
function Quests:showMainQuestTypes(viewElement, listView)
	local REGULAR = 1
	local LIMITED = 2
	local RANKED = 3
	local BATTLEPASS = 4

	---@type QuestCategory[]
	local regularQuestList = {
		{
			name = TB_MENU_LOCALIZED.QUESTSREPEATING,
			quests = { },
			canBeClaimed = { }
		},
		{
			name = TB_MENU_LOCALIZED.QUESTSLIMITED,
			quests = { },
			canBeClaimed = { }
		},
		{
			name = TB_MENU_LOCALIZED.QUESTSRANKED,
			quests = { },
			canBeClaimed = { }
		},
		{
			name = TB_MENU_LOCALIZED.QUESTSBATTLEPASS,
			quests = { },
			canBeClaimed = { }
		}
	}

	---@param quest QuestData
	---@param section integer
	local function putQuestInSection(quest, section)
		table.insert(regularQuestList[section].quests, quest)
		if (quest.progress >= quest.requirement) then
			table.insert(regularQuestList[section].canBeClaimed, quest)
		end
	end

	for _ ,v in pairs(Quests.QuestsData) do
		if (v.ranked) then
			putQuestInSection(v, RANKED)
		elseif (v.bp_xp > 0) then
			putQuestInSection(v, BATTLEPASS)
		elseif (v.timeleft > 0) then
			putQuestInSection(v, LIMITED)
		else
			putQuestInSection(v, REGULAR)
		end
	end

	local GLOBALACTIVE = 1
	local GLOBALCOMPLETED = 2
	---@type QuestCategory[]
	local globalQuestList = {
		{
			name = TB_MENU_LOCALIZED.QUESTSGLOBALACTIVE,
			quests = { },
			canBeClaimed = { }
		},
		{
			name = TB_MENU_LOCALIZED.QUESTSGLOBALCOMPLETED,
			quests = { },
			canBeClaimed = { }
		}
	}
	for _, v in pairs(Quests.QuestsGlobalData) do
		if (v.claimed) then
			table.insert(globalQuestList[GLOBALCOMPLETED].quests, v)
		else
			table.insert(globalQuestList[GLOBALACTIVE].quests, v)
			if (v.progress >= v.requirement) then
				table.insert(globalQuestList[GLOBALACTIVE].canBeClaimed, v)
			end
		end
	end

	globalQuestList[GLOBALCOMPLETED].quests = table.qsort(globalQuestList[GLOBALCOMPLETED].quests, { "requirement", "type" }, { SORT_ASCENDING })

	local elementHeight = 50
	local toReload, topBar, botBar, _, listingHolder = TBMenu:prepareScrollableList(viewElement, 70, elementHeight, 20, TB_MENU_DEFAULT_BG_COLOR)
	local listElements = {}

	topBar:addChild({ shift = { 10, 5 } }):addAdaptedText(TB_MENU_LOCALIZED.NAVBUTTONQUESTS, nil, nil, FONTS.BIG, nil, 0.7)
	TBMenu:addBottomBloodSmudge(botBar, 1)

	local regularQuestsTitle = listingHolder:addChild({
		pos = { 0, 0 },
		size = { listingHolder.size.w, elementHeight }
	})
	table.insert(listElements, regularQuestsTitle)
	regularQuestsTitle:addChild({ shift = { 15, 5 }}):addAdaptedText(TB_MENU_LOCALIZED.QUESTSREGULAR, nil, nil, FONTS.BIG, LEFTMID)

	if (regularQuestList[TB_MENU_QUESTS_ACTIVE_SECTION] == nil or #regularQuestList[TB_MENU_QUESTS_ACTIVE_SECTION].quests < 1) then
		TB_MENU_QUESTS_ACTIVE_SECTION = 1
	end
	regularQuestList[TB_MENU_QUESTS_ACTIVE_SECTION].selected = true
	for i,v in pairs(regularQuestList) do
		Quests:displayMainQuestTypeButton(listingHolder, v, listElements, elementHeight, listView, i)
	end

	table.insert(listElements, listingHolder:addChild({
		pos = { 0, #listElements * elementHeight },
		size = { listingHolder.size.w, elementHeight }
	}))

	local globalQuestsTitle = listingHolder:addChild({
		pos = { 0, #listElements * elementHeight },
		size = { listingHolder.size.w, elementHeight }
	})
	table.insert(listElements, globalQuestsTitle)
	globalQuestsTitle:addChild({ shift = { 15, 5 }}):addAdaptedText(TB_MENU_LOCALIZED.QUESTSGLOBAL, nil, nil, FONTS.BIG, LEFTMID)

	for _, v in pairs(globalQuestList) do
		Quests:displayMainQuestTypeButton(listingHolder, v, listElements, elementHeight, listView)
	end

	if (#listElements * elementHeight > listingHolder.size.h) then
		for _, v in pairs(listElements) do
			v:hide()
		end

		local scrollBar = TBMenu:spawnScrollBar(listingHolder, #listElements, elementHeight)
		listingHolder.scrollBar = scrollBar
		scrollBar:makeScrollBar(listingHolder, listElements, toReload)
	else
		listingHolder:moveTo((listingHolder.parent.size.w - listingHolder.size.w) / 4, nil, true)
	end

	Quests:showMainQuestList(listView, regularQuestList[TB_MENU_QUESTS_ACTIVE_SECTION])
end

---Displays the main Quests screen
---@param navBack? boolean
---@param backFunc? function
function Quests:showQuests(navBack, backFunc)
	TBMenu:clearNavSection()
	TBMenu:showNavigationBar(Notifications:getNavigationButtons(navBack, nil, backFunc), true, true, 2)

	local questTypesView = TBMenu.CurrentSection:addChild({
		pos = { 5, 0 },
		size = { TBMenu.CurrentSection.size.w / 4 - 10, TBMenu.CurrentSection.size.h },
		bgColor = TB_MENU_DEFAULT_BG_COLOR
	})
	local questListView = TBMenu.CurrentSection:addChild({
		pos = { questTypesView.shift.x + questTypesView.size.w + 10, 0 },
		size = { TBMenu.CurrentSection.size.w - questTypesView.shift.x - questTypesView.size.w - 15, TBMenu.CurrentSection.size.h },
		bgColor = TB_MENU_DEFAULT_BG_COLOR
	})
	Quests:showMainQuestTypes(questTypesView, questListView)
end

---Prepares the main Quests screen for display.\
---If quests data is empty, fetches and parses the data file first.
---@param navBack? boolean
---@param backFunc? function
function Quests:showMain(navBack, backFunc)
	usage_event("quests")
	if (Quests.QuestsData and not Quests:requiresGlobalDataUpdate()) then
		Quests:showQuests(navBack, backFunc)
		return
	end
	TBMenu:clearNavSection()
	TBMenu:showNavigationBar(Notifications:getNavigationButtons(navBack, nil, backFunc), true, true, 2)

	Quests:download()
	local updatingView = TBMenu.CurrentSection:addChild({
		shift = { 5, 0 },
		bgColor = TB_MENU_DEFAULT_BG_COLOR
	})
	TBMenu:displayLoadingMark(updatingView, TB_MENU_LOCALIZED.QUESTSUPDATING)
	TBMenu:addBottomBloodSmudge(updatingView, 1)
	local spawnClock = os.clock_real()
	updatingView:addCustomDisplay(function()
			if (Quests.QuestsData and Quests.QuestsGlobalData) then
				Quests:showQuests(navBack, backFunc)
			end
			if (os.clock_real() - spawnClock > 10 and Quests.QuestDataErrors > 0) then
				updatingView:kill(true)
				updatingView:addAdaptedText(TB_MENU_LOCALIZED.ERRORTRYAGAIN)
				TBMenu:addBottomBloodSmudge(updatingView, 1)
			end
		end)
end
